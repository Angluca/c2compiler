/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module string_pool;

import string;
import stdlib;
import stdio;

const u32 HASH_TABLE_SIZE = 256;

public type Pool struct @(opaque) {
    u32 data_size;      // number of bytes used
    u32 data_capacity;
    char* data;

    // statistics
    u32 num_adds;
    u32 total_size;     // total size that would have been allocated without filtering

    // Hashtable
    u8[HASH_TABLE_SIZE] entry_count;    // Note: max 256 entries per hash
    u32 entry_capacity;
    // just make all entries the same size (entry_capacity)
    u32* entries;   // can be nil, contain indexes of all strings, entry_capacity*HASH_TABLE_SIZE
}
static_assert(296, sizeof(Pool));

public fn Pool* create(u32 data_capacity, u32 hash_capacity) {
    Pool* p = stdlib.calloc(1, sizeof(Pool));
    p.resize_data(data_capacity);
    p.data[0] = 0;
    p.data_size = 1; // skip 1 (used to store empty strings)

    p.entries = nil;
    string.memset(p.entry_count, 0, sizeof(p.entry_count));
    p.entry_capacity = hash_capacity;
    if (hash_capacity) {
        p.resize_hash(hash_capacity);
    }

    return p;
}

public fn void Pool.free(Pool* p) {
    stdlib.free(p.entries);
    stdlib.free(p.data);
    stdlib.free(p);
}

const u32 HASH_INITIAL = 13;
const u32 HASH_PRIME = 17;

fn u32 hash(const char* text, usize len) {
    // FNV-1a hash
    u32 result = HASH_INITIAL;
    for (u32 i=0; i<len; i++) {
        result = result ^ text[i];
        result *= HASH_PRIME;
    }
    return result % HASH_TABLE_SIZE;
}

public fn const char* Pool.getStart(const Pool* p) { return p.data; }

public fn const char* Pool.idx2str(const Pool* p, u32 idx) {
    return p.data + idx;
}

// NOTE: right is NOT 0-terminated!
// 0 left
// 1 right
// 2 equal
fn u32 compare(const char* left, const char* right, usize rlen) {
    u32 i = 0;
    while (i < rlen) {
        char l = left[i];
        char r = right[i];
        i32 c = l - r;
        if (c < 0) return 1;
        if (c > 0) return 0;
        i++;
    }
    if (left[rlen] == 0) return 2;
    return 0;
}


// NOTE: text is not 0-terminated!! len is strlen(text)
public fn u32 Pool.add(Pool* p, const char* text, usize len, bool filter) {
    p.num_adds++;
    p.total_size += len;

    if (filter) {
        u32 hashcode = hash(text, len);
        u8 count = p.entry_count[hashcode];
        u32* indexes = &p.entries[hashcode * p.entry_capacity];
        for (u32 i=0; i<count; i++) {
            const char* word = p.data + indexes[i];
            if (compare(word, text, len) == 2) {
                return indexes[i];
            }
        }
        if (count == p.entry_capacity) {
            p.resize_hash(p.entry_capacity * 2);
            indexes = &p.entries[hashcode * p.entry_capacity];
        }
        indexes[count] = p.data_size; // will be inserted here
        p.entry_count[hashcode]++;
    }

    while (p.data_size + len + 1 > p.data_capacity) {
        if (text >= p.data && text < p.data + p.data_size) {
            /* adding a fragment from an existing word in the array */
            // NOTE: users should NOT keep pointers to data, because reallocating will move the array
            isize offset = text - p.data;
            p.resize_data(p.data_capacity * 2);
            text = p.data + offset;
        } else {
            p.resize_data(p.data_capacity * 2);
        }
    }
    u32 idx = p.data_size;
    char* dest = p.data + p.data_size;
    string.memcpy(dest, text, len);
    dest[len] = 0;
    p.data_size += len + 1;
    //assert(p.data_size <= p.data_capacity);
    return idx;
}

public fn u32 Pool.addStr(Pool* p, const char* text, bool filter) {
    return p.add(text, string.strlen(text), filter);
}

fn void Pool.resize_data(Pool* p, u32 capacity) {
    p.data_capacity = capacity;
    char* data2 = stdlib.malloc(capacity);
    if (p.data_size) {
        string.memcpy(data2, p.data, p.data_size);
        stdlib.free(p.data);
    }
    p.data = data2;
}

fn void Pool.resize_hash(Pool* p, u32 capacity) {
    u32* entries = stdlib.malloc(capacity * sizeof(u32) * HASH_TABLE_SIZE);
    if (p.entries) {
        for (u32 i=0; i<HASH_TABLE_SIZE; i++) {
            string.memcpy(&entries[i*capacity], &p.entries[i*p.entry_capacity], p.entry_count[i]*sizeof(u32));
        }
        stdlib.free(p.entries);
    }
    p.entry_capacity = capacity;
    p.entries = entries;
}

public fn void Pool.report(const Pool* p) {
    u32 max = 0;
    u32 min = 999;
    u32 count = 0;
    for (u32 i=0; i<HASH_TABLE_SIZE; i++) {
        u32 num = p.entry_count[i];
        count += num;
        if (num) {
            if (num > max) max = num;
            if (num < min) min = num;
            //stdio.printf("[%4d] %d\n", i, num);
        }
    }
    stdio.printf("pool: %d(%d) adds, data %d(%d)/%d bytes\n",
        count, p.num_adds,
        p.data_size, p.total_size, p.data_capacity);

    stdio.printf("  hash: %d entries, min %d max %d\n", HASH_TABLE_SIZE, min, max);
#if 0
    const char* end = p.data + p.data_size;
    const char* cp = p.data;
    u32 idx = 0;
    while (cp < end) {
        stdio.printf("  [%5u] %s\n", idx, cp);
        idx++;
        while (*cp != 0) cp++;
        cp++;
    }
#endif
}

