/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ir_generator;

import ast local;
import ir local;
import ir_gen_locals local;
import ctv_analyser;

fn void Generator.emitExpr(Generator* gen, ir.Ref* result, const Expr* e) {
    if (e.isCtv()) {
        Value v = ctv_analyser.get_value(e);
        // TEMP as u32 TODO
        *result = gen.ctx.addIntegerConstant(v.as_u32());
        return;
    }

    // TODO rest
    switch (e.getKind()) {
    case IntegerLiteral:
    case FloatLiteral:
    case BooleanLiteral:
    case CharLiteral:
        assert(0);  // should be handled by CTV above
        break;
    case StringLiteral:
        StringLiteral* s = cast<StringLiteral*>(e);

        SymbolId id = gen.ctx.addStringLiteral(gen.createStringVar(), s.getText(), s.getSize());
        ir.Ref ref;
        ref.init(RefKind.Symbol, id);
        *result = ref;
        break;
    case Nil:
        *result = gen.ctx.addIntegerConstant(0);
        break;
    case Identifier:
        gen.emitIdentifier(result, e);
        break;
    case Type:
        assert(0);
        break;
    case Call:
        gen.emitCallExpr(result, e);
        break;
    case InitList:
        // TODO BB just emit 0 constant
        *result = gen.ctx.addIntegerConstant(0);
        break;
    case FieldDesignatedInit:
    case ArrayDesignatedInit:
        assert(0);
        break;
    case BinaryOperator:
        gen.emitBinaryOperator(result, e);
        break;
    case UnaryOperator:
        gen.emitUnaryOperator(result, e);
        break;
    case ConditionalOperator:
        gen.emitCondOperator(result, e);
        break;
    case Builtin:
        gen.emitBuiltin(result, e);
        break;
    case ArraySubscript:
        gen.emitArraySubscript(result, e);
        break;
    case Member:
        gen.emitMemberExpr(result, e);
        break;
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        gen.emitExpr(result, p.getInner());
        break;
    case BitOffset:
        assert(0); // TODO
        // TODO
        break;
    case ExplicitCast:
        ExplicitCastExpr* ec = cast<ExplicitCastExpr*>(e);
        // TODO
        gen.emitExpr(result, ec.getInner());
        break;
    case ImplicitCast:
        ImplicitCastExpr* ic = cast<ImplicitCastExpr*>(e);
        switch (ic.getKind()) {
        case ArrayToPointerDecay:
            // just ignore, pass inner
            gen.emitExpr(result, ic.getInner());
            break;
        case LValueToRValue:
            // turn into load
            ir.Ref src;
            gen.emitExpr(&src, ic.getInner());
            // TODO get type for Expr
            *result = gen.ctx.addLoadInstr(ir.Type.I32, src);
            break;
        case PointerToBoolean:
            gen.emitExpr(result, ic.getInner());
            //assert(0);
            break;
        case PointerToInteger:
            assert(0);
            break;
        case IntegralCast:
            //stdio.printf("WARNING: IntegralCast (skipping for now)\n");
            gen.emitExpr(result, ic.getInner());
            break;
        case BitCast:
            assert(0);
            break;
        }
        break;
    }
}

fn void Generator.emitIdentifier(Generator* gen, ir.Ref* result, const Expr* e) {
    IdentifierExpr* i = cast<IdentifierExpr*>(e);

    switch (i.getKind()) {
    case Unresolved:
    case Module:
        assert(0);
        break;
    case Function:
        gen.emitSymbol(result, i.getDecl());
        break;
    case Type:
        assert(0);
        break;
    case Var:
        gen.emitVarDecl(result, i.getDecl());
        break;
    case EnumConstant:
        assert(0); // TODO
        break;
    case StructMember:
    case Label:
        assert(0);
        break;
    }
}

fn void Generator.emitSymbol(Generator* gen, ir.Ref* result, Decl* d) {
    SymbolId sid = gen.createSymbol(d);
    ir.Ref ref;
    ref.init(RefKind.Symbol, sid);
    *result = ref;
}

fn void Generator.emitVarDecl(Generator* gen, ir.Ref* result, Decl* d) {
    const VarDecl* vd = cast<VarDecl*>(d);
    if (vd.isGlobal()) {
        gen.emitSymbol(result, d);
    } else if (vd.hasLocalQualifier()) {
        // use: function.name
        u32 gen_idx = d.getGenIdx();
        if (!gen_idx) {
            QualType qt = d.getType();
            gen_idx = gen.ctx.addGlobal(gen.createLocalName(d), qt.getAlignment());
            d.setGenIdx(gen_idx);
        }
        ir.Ref ref;
        ref.init(RefKind.Symbol, gen_idx);
        *result = ref;
    } else if (vd.isLocal() || vd.isParameter()) {
        StackVar* var = gen.locals.find(vd);
        *result = var.slot;
    } else {
        assert(0);
    }
}

fn void Generator.emitCondOperator(Generator* gen, ir.Ref* result, const Expr* e) {
    ir.Context* c = gen.ctx;
    const ConditionalOperator* co = cast<ConditionalOperator*>(e);

    // TEMP just emit LHS
    gen.emitExpr(result, co.getLHS());
#if 0
    BlockId then_blk = c.createBlock(BlockKind.CondTrue);
    BlockId else_blk = c.createBlock(BlockKind.CondFalse);
    BlockId join_blk = c.createBlock(BlockKind.CondJoin);

    // cond
    gen.emitCond(co.getCond(), then_blk, else_blk, then_blk);

    // HMM nasty, need Phi? (or 2 stores)
    // a = (cond) ? 1 : 2; -> can be 2 stores OR Phi instruction

    // true
    ir.Ref ref1;
    gen.emitExpr(&ref1, co.getLHS());
    if (!c.isBlockTerminated()) c.addJmpInstr(join_blk);
    c.endBlock();

    // false
    ir.Ref ref2;
    gen.emitExpr(&ref1, co.getRHS());
    if (!c.isBlockTerminated()) c.addJmpInstr(join_blk);
    c.endBlock();

    // join block
    c.startBlock(join_blk);
    *result = ref2; // TEMP
#endif
}

fn void Generator.emitUnaryOperator(Generator* gen, ir.Ref* result, const Expr* e) {
    const UnaryOperator* uo = cast<UnaryOperator*>(e);

    switch (uo.getOpcode()) {
    case PostInc:
    case PostDec:
    case PreInc:
    case PreDec:
        // TODO what if (*cp)++ ?
        ir.Ref left;
        gen.emitExpr(&left, uo.getInner());

        // create load
        ir.Type t = ir.Type.I32; // TODO get type from Expr
        ir.Ref left_val = gen.ctx.addLoadInstr(t, left);

        // add/sub
        ir.Ref value = gen.ctx.addIntegerConstant(1);
        InstrKind k;
        if (uo.getOpcode() == UnaryOpcode.PostInc || uo.getOpcode() == UnaryOpcode.PreInc) {
            k = InstrKind.Add;
        } else {
            k = InstrKind.Sub;
        }
        ir.Ref right = gen.ctx.addBinaryInstr(k, left_val, value);

        // store
        gen.ctx.addStoreInstr(t, left, right);
        if (uo.getOpcode() <= UnaryOpcode.PostDec) {
            *result = left_val;
        } else {
            *result = right;
        }
        break;
    case AddrOf:
    case Deref:
        // Note: deref has LValueToRValue to creates load, voila
        gen.emitExpr(result, uo.getInner());
        break;
    case Plus:
    case Minus:
        // Note: [-+]<constant> will not happen here, since they are CTV and already handled
#if 0
        assert(e.isCtc());
        Value v = ctv_analyser.get_value(e);
        //v.mask(32);
        // TEMP now only 32-bit
        //i32 s = cast<i32>(v.svalue);
        //printf("Value %d  %d  %d\n", v.svalue, v.uvalue, cast<u32>(s));
        //out.print("%d", cast<u32>(s));
        out.print("%d", v.as_u32());
#endif
        break;
    case Not:
        ir.Ref lhs;
        gen.emitExpr(&lhs, uo.getInner());

        // xor with -1
        ir.Ref rhs = gen.ctx.addIntegerConstant(-1);
        *result = gen.ctx.addBinaryInstr(InstrKind.Xor, lhs, rhs);
        break;
    case LNot:
        ir.Ref lhs;
        gen.emitExpr(&lhs, uo.getInner());

        // convert integer to bool: compare to 0
        ir.Ref zero = gen.ctx.addIntegerConstant(0);
        ir.Ref rhs = gen.ctx.addBinaryInstr(InstrKind.CmpNe, lhs, zero);

        // invert: xor with 1
        ir.Ref one = gen.ctx.addIntegerConstant(1);
        rhs = gen.ctx.addBinaryInstr(InstrKind.Xor, rhs, one);

        // TODO zext i1 -> i32
        *result = rhs;
        break;
    }
}

// EmitCond will end with the true_blk started
fn void Generator.emitCond(Generator* gen, const Expr* e, BlockId true_blk, BlockId false_blk, BlockId start_blk) {
    ir.Context* c = gen.ctx;

    if (e.isCtv()) {
        Value v = ctv_analyser.get_value(e);
        if (v.isZero()) {
            c.addJmpInstr(false_blk);
        } else {
            c.addJmpInstr(true_blk);
        }
        c.endBlock();
        c.startBlock(start_blk);
        return;
    }

    ir.Ref ref;

    switch (e.getKind()) {
    case IntegerLiteral:
    case FloatLiteral:
    case BooleanLiteral:
    case CharLiteral:
    case StringLiteral:
    case Nil:
        assert(0);  // CTV
        break;
    case Identifier:
        assert(0); // should have cast?
        break;
    case Type:
        assert (0);
        break;
    case Call:
        break;
    case InitList:
    case FieldDesignatedInit:
    case ArrayDesignatedInit:
        assert (0);
        break;
    case BinaryOperator:
        if (gen.emitBinaryCond(e, true_blk, false_blk, start_blk)) return;
        break;
    case UnaryOperator:
        break;
    case ConditionalOperator:
        assert(0);
        break;
    case Builtin:
        assert(0);  // CTV
        break;
    case ArraySubscript:
    case Member:
        break;
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        gen.emitCond(p.getInner(), true_blk, false_blk, start_blk);
        return;
    case BitOffset:
    case ExplicitCast:
    case ImplicitCast:
        break;
    }
    gen.emitExpr(&ref, e);
    ir.Ref zero = gen.ctx.addIntegerConstant(0);
    ir.Ref cond = gen.ctx.addBinaryInstr(InstrKind.CmpNe, ref, zero);
    c.addJmpIfInstr(cond, true_blk, false_blk);
    c.endBlock();
    c.startBlock(start_blk);


}

fn void Generator.emitAssignCond(Generator* gen, ir.Type t, ir.Ref lhs, ir.Ref rhs, BlockId left, BlockId right, BlockId start) {
    Context* c = gen.ctx;
    // if (a = getchar()), emit:
    //   %x = getchar()
    //   store a, %x
    //   icmp ne %x, 0
    c.addStoreInstr(t, lhs, rhs);
    ir.Ref zero = gen.ctx.addIntegerConstant(0);
    ir.Ref cond = gen.ctx.addBinaryInstr(InstrKind.CmpNe, rhs, zero);
    c.addJmpIfInstr(cond, left, right);
    c.endBlock();
    c.startBlock(start);
}

// return true if it was handled
fn bool Generator.emitBinaryCond(Generator* gen, const Expr* e, BlockId left, BlockId right, BlockId start) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);

    InstrKind k;
    switch (b.getOpcode()) {
    case LessThan:
        k = InstrKind.CmpLt;
        break;
    case GreaterThan:
        k = InstrKind.CmpGt;
        break;
    case LessEqual:
        k = InstrKind.CmpLe;
        break;
    case GreaterEqual:
        k = InstrKind.CmpGe;
        break;
    case Equal:
        k = InstrKind.CmpEq;
        break;
    case NotEqual:
        k = InstrKind.CmpNe;
        break;
    case LAnd:
        gen.emitAndCond(b, left, right);
        return true;
    case LOr:
        gen.emitOrCond(b, left, right, start);
        return true;
    case Assign:
        // TODO should check for CTV values
        ir.Ref rhs;
        gen.emitExpr(&rhs, b.getRHS());
        ir.Ref lhs;
        gen.emitExpr(&lhs, b.getLHS());
        ir.Type t = ir.Type.I32; // TODO get type
        gen.emitAssignCond(t, lhs, rhs, left, right, start);
        return true;
    default:
        return false;
    }

    ir.Ref lhs;
    gen.emitExpr(&lhs, b.getLHS());
    ir.Ref rhs;
    gen.emitExpr(&rhs, b.getRHS());
    ir.Ref cond = gen.ctx.addBinaryInstr(k, lhs, rhs);
    Context* c = gen.ctx;
    c.addJmpIfInstr(cond, left, right);
    c.endBlock();
    c.startBlock(start);
    return true;
}

fn void Generator.emitAndCond(Generator* gen, const BinaryOperator* b, BlockId true_blk, BlockId false_blk) {
    BlockId and_true = gen.ctx.createBlock(BlockKind.AndTrue);

    gen.emitCond(b.getLHS(), and_true, false_blk, and_true);
    gen.emitCond(b.getRHS(), true_blk, false_blk, true_blk);
}

fn void Generator.emitOrCond(Generator* gen, const BinaryOperator* b, BlockId true_blk, BlockId false_blk, BlockId start_blk) {
    BlockId or_false = gen.ctx.createBlock(BlockKind.OrFalse);

    gen.emitCond(b.getLHS(), true_blk, or_false, or_false);
    gen.emitCond(b.getRHS(), true_blk, false_blk, start_blk);
}

fn void Generator.emitBuiltin(Generator* gen, ir.Ref* result, const Expr* e) {
    const BuiltinExpr* bi = cast<BuiltinExpr*>(e);
    switch (bi.getKind()) {
    case Sizeof:
    case Elemsof:
    case EnumMin:
    case EnumMax:
    case OffsetOf:
        e.dump();
        assert(0);
        break;
    case ToContainer: {
            ir.Ref ptr_ref;
            gen.emitExpr(&ptr_ref, bi.getToContainerPointer());
            Value v = bi.getValue();
            u32 offset = v.as_u32();
            if (offset == 0) {
                *result = ptr_ref;
            } else {
                ir.Ref offset_ref = gen.ctx.addIntegerConstant(offset);
                *result = gen.ctx.addBinaryInstr(InstrKind.Sub, ptr_ref, offset_ref);
            }
            break;
        }
    }
}

fn void Generator.emitArraySubscript(Generator* gen, ir.Ref* result, const Expr* e) {
    const ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
    Expr* base = a.getBase();
    Expr* index = a.getIndex();
    QualType qt = base.getType();
    u32 base_size = qt.getSize(true);

    if (index.isCtv()) {
        ir.Ref base_ref;
        gen.emitExpr(&base_ref, base);

        // offset = value * base_size;
        Value v = ctv_analyser.get_value(index);
        u32 offset = v.as_u32() * base_size;
        if (offset == 0) {
            *result = base_ref;
        } else {
            ir.Ref offset_ref = gen.ctx.addIntegerConstant(offset);
            // add base and offset
            *result = gen.ctx.addBinaryInstr(InstrKind.Add, base_ref, offset_ref);
        }
    } else {
        ir.Ref base_ref;
        gen.emitExpr(&base_ref, base);

        ir.Ref idx_ref;
        gen.emitExpr(&idx_ref, index);

        // offset = value * base_size;
        if (base_size == 1) {
            *result = gen.ctx.addBinaryInstr(InstrKind.Add, base_ref, idx_ref);
        } else {
            ir.Ref size_ref = gen.ctx.addIntegerConstant(base_size);
            ir.Ref offset_ref = gen.ctx.addBinaryInstr(InstrKind.Mul, idx_ref, size_ref);
            // add base and offset
            *result = gen.ctx.addBinaryInstr(InstrKind.Add, base_ref, offset_ref);
        }
    }
}

fn void Generator.emitMemberExpr(Generator* gen, ir.Ref* result, const Expr* e) {
    const MemberExpr* m = cast<MemberExpr*>(e);
    Context* c = gen.ctx;

    u32 tail = 0;

    IdentifierKind kind = m.getKind();
    if (kind == IdentifierKind.Var || kind == IdentifierKind.Function) {
        // TODO handle struct function (Analyser will have checked that it's followed by call)
        if (m.isTypeFunc()) {
            // only emit base part, not last
            tail = 1;
            goto next;
        }

        if (m.hasExpr()) {
            // TODO can be <expr>.<type_func> or <expr>.a.<type_func>
            //e.dump();
            goto next;
        }
        assert(!m.hasExpr());
        Decl* d = m.getFullDecl();
        gen.emitSymbol(result, d);
        return;
    }

    assert(kind == IdentifierKind.StructMember);
next:
    {}
#if 0
    if (m.hasExpr()) {
        const Expr* base = m.getExprBase();
        base.dump();
    }
    for (u32 i=0; i<m.getNumRefs(); i++) {
        Decl* d = m.getDecl(i);
        QualType qt = d.getType();
        bool needs_deref = qt.isPointer();
        stdio.printf("REF[%d/%d] %d\n", i, m.getNumRefs(), needs_deref);
        d.dump();
    }
#endif

    // base
    ir.Ref base_ref;
    QualType base_type;
    u32 idx = 0;
    if (m.hasExpr()) {
        const Expr* base = m.getExprBase();
        gen.emitExpr(&base_ref, base);
        base_type = base.getType();
    } else {
        Decl* base = m.getDecl(idx);
        if (base.isImport()) {  // skip module prefix
            idx++;
            base = m.getDecl(idx);
        }
        idx++;
        assert(base.isVarDecl());
        gen.emitVarDecl(&base_ref, base);
        base_type = base.getType();
    }

    // member (a.b.c.etc)
    u32 numrefs = m.getNumRefs();
    numrefs -= tail;
    for (u32 i=idx; i<numrefs; i++) {
        if (base_type.isPointer()) { // insert load to de-ref
            base_ref = c.addLoadInstr(ir.Type.I32, base_ref);
            base_type = base_type.getPointerBaseType();
        }

        assert(base_type.isStruct());
        const StructType* st = base_type.getStructType();
        const StructTypeDecl* std = st.getDecl();

        Decl* d = m.getDecl(i);

        u32 offset = 0;
        Decl* dd = std.findMember(d.getNameIdx(), &offset);
        if (!dd) {
            e.dump();
        }
        assert(dd);

        if (offset != 0) {
            ir.Ref offset_ref = c.addIntegerConstant(offset);
            base_ref = c.addBinaryInstr(InstrKind.Add, base_ref, offset_ref);
        }

        base_type = d.getType();
    }
    *result = base_ref;
}

