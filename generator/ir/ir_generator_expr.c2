/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ir_generator;

import ast local;
import constants;
import ir local;
import ir_gen_locals local;
import ctv_analyser;

import stdio;

fn void Generator.emitExpr(Generator* gen, ir.Ref* result, const Expr* e) {
    if (e.isCtv()) {
        Value v = ctv_analyser.get_value(e);
        // TEMP as u32 TODO
        *result = gen.ctx.addIntegerConstant(v.as_u32());
        return;
    }

    // TODO rest
    switch (e.getKind()) {
    case IntegerLiteral:
    case FloatLiteral:
    case BooleanLiteral:
    case CharLiteral:
        assert(0);  // should be handled by CTV above
        break;
    case StringLiteral:
        // TODO check if already generated
        StringLiteral* s = cast<StringLiteral*>(e);
        //gen.createString(result, s.getText());
        break;
    case Nil:
        *result = gen.ctx.addIntegerConstant(0);
        break;
    case Identifier:
        gen.emitIdentifier(result, e);
        break;
    case Type:
        assert(0);
        break;
    case Call:
        gen.emitCallExpr(result, e);
        break;
    case InitList:
    case FieldDesignatedInit:
    case ArrayDesignatedInit:
        assert(0);
        break;
    case BinaryOperator:
        gen.emitBinaryOperator(result, e);
        break;
    case UnaryOperator:
        gen.emitUnaryOperator(result, e);
        break;
    case ConditionalOperator:
        gen.emitCondOperator(result, e);
        break;
    case Builtin:
        // already done since CTV
        assert(0);
        break;
    case ArraySubscript:
        gen.emitArraySubscript(result, e);
        break;
    case Member:
        gen.emitMemberExpr(result, e);
        break;
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        gen.emitExpr(result, p.getInner());
        break;
    case BitOffset:
        assert(0); // TODO
        // TODO
        break;
    case ExplicitCast:
        assert(0); // TODO
        // TODO
        break;
    case ImplicitCast:
        ImplicitCastExpr* ic = cast<ImplicitCastExpr*>(e);
        switch (ic.getKind()) {
        case ArrayToPointerDecay:
            // just ignore, pass inner
            gen.emitExpr(result, ic.getInner());
            break;
        case FunctionToPointerDecay:
            // just ignore, pass inner
            gen.emitExpr(result, ic.getInner());
            break;
        case LValueToRValue:
            // turn into load
            ir.Ref src;
            gen.emitExpr(&src, ic.getInner());
            // TODO get type for Expr
            *result = gen.ctx.addLoadInstr(ir.Type.I32, src);
            break;
        case PointerToBoolean:
            gen.emitExpr(result, ic.getInner());
            //assert(0);
            break;
        case PointerToInteger:
            assert(0);
            break;
        case IntegralCast:
            //stdio.printf("WARNING: IntegralCast (skipping for now)\n");
            gen.emitExpr(result, ic.getInner());
            break;
        case BitCast:
            assert(0);
            break;
        }
        break;
    }
}

fn void Generator.emitCallExpr(Generator* gen, ir.Ref* result, const Expr* e) {
    CallExpr* ce = cast<CallExpr*>(e);
    Context* c = gen.ctx;

    u32 num_args = ce.getNumArgs();
    Expr** args = ce.getArgs();

    QualType qt = e.getType();
    bool has_result = !qt.isVoid();

    ir.Ref args_ref;
    // TODO auto args, struct/enum-functions, etc
    if (num_args == 0) {
        args_ref.init(RefKind.None, 0);
    } else {
        args_ref.init(RefKind.RefList, c.getRefsCount());
    }

    for (u32 i=0; i<num_args; i++) {
        ir.Ref ref;
        // TODO conversions?
        gen.emitExpr(&ref, args[i]);
        c.addCallArg(ref);
    }
    // Terminate with Ref.Unspecified
    if (num_args) {
        ir.Ref ref;
        ref.init(RefKind.None, 0);
        c.addCallArg(ref);
    }

    ir.Ref name_ref;
    // TODO should be RefKind.Addr -> hmm, for now store text
    // TEMP
    u32 name_idx = c.addStr("funcname");
    name_ref.init(RefKind.Text, name_idx);
    *result = c.addCallInstr(name_ref, args_ref, has_result);
}

fn void Generator.emitIdentifier(Generator* gen, ir.Ref* result, const Expr* e) {
    IdentifierExpr* i = cast<IdentifierExpr*>(e);

    switch (i.getKind()) {
    case Unresolved:
    case Module:
        assert(0);
        break;
    case Function:
        assert(0); // TODO
        //getGlobalName(result.ref, i.getDecl());
        break;
    case Type:
        assert(0);
        break;
    case Var:
        gen.emitVarDecl(result, i.getDecl());
        break;
    case EnumConstant:
        assert(0); // TODO
        break;
    case StructMember:
    case Label:
        assert(0);
        break;
    }
}

fn void Generator.emitVarDecl(Generator* gen, ir.Ref* result, const Decl* d) {
    const VarDecl* vd = cast<VarDecl*>(d);
    if (vd.isGlobal()) {
        //getGlobalName(result.ref, d);
        assert(0); // TODO
    } else if (vd.hasLocalQualifier()) {
        assert(0); // TODO
    } else if (vd.isLocal() || vd.isParameter()) {
        StackVar* var = gen.locals.find(vd);
        *result = var.slot;
    } else {
        assert(0);
    }
}

fn void Generator.emitCondOperator(Generator* gen, ir.Ref* result, const Expr* e) {
    ir.Context* c = gen.ctx;
    const ConditionalOperator* co = cast<ConditionalOperator*>(e);
    assert(0);
#if 0
    BlockId then_blk = c.createBlock(BlockKind.CondTrue);
    BlockId else_blk = c.createBlock(BlockKind.CondFalse);
    BlockId join_blk = c.createBlock(BlockKind.CondJoin);

    // cond
    gen.emitCond(co.getCond(), then_blk, else_blk, then_blk);

    // HMM nasty, need Phi? (or 2 stores)
    // a = (cond) ? 1 : 2; -> can be 2 stores OR Phi instruction

    // true
    ir.Ref ref1;
    gen.emitExpr(&ref1, co.getLHS());
    if (!c.isBlockTerminated()) c.addJmpInstr(join_blk);
    c.endBlock();

    // false
    ir.Ref ref2;
    gen.emitExpr(&ref1, co.getRHS());
    if (!c.isBlockTerminated()) c.addJmpInstr(join_blk);
    c.endBlock();

    // join block
    c.startBlock(join_blk);
    *result = ref2; // TEMP
#endif
}

fn void Generator.emitUnaryOperator(Generator* gen, ir.Ref* result, const Expr* e) {
    const UnaryOperator* uo = cast<UnaryOperator*>(e);

    switch (uo.getOpcode()) {
    case PostInc:
    case PostDec:
    case PreInc:
    case PreDec:
        // TODO what if (*cp)++ ?
        ir.Ref left;
        gen.emitExpr(&left, uo.getInner());

        // create load
        ir.Type t = ir.Type.I32; // TODO get type from Expr
        ir.Ref left_val = gen.ctx.addLoadInstr(t, left);

        // add/sub
        ir.Ref value = gen.ctx.addIntegerConstant(1);
        InstrKind k;
        if (uo.getOpcode() == UnaryOpcode.PostInc || uo.getOpcode() == UnaryOpcode.PreInc) {
            k = InstrKind.Add;
        } else {
            k = InstrKind.Sub;
        }
        ir.Ref right = gen.ctx.addBinaryInstr(k, left_val, value);

        // store
        gen.ctx.addStoreInstr(t, left, right);
        if (uo.getOpcode() <= UnaryOpcode.PostDec) {
            *result = left_val;
        } else {
            *result = right;
        }
        break;
    case AddrOf:
    case Deref:
        // Note: deref has LValueToRValue to creates load, voila
        gen.emitExpr(result, uo.getInner());
        break;
    case Minus:
        // Note: -<constant> will not happen here, since they are CTV and already handled
#if 0
        assert(e.isCtc());
        Value v = ctv_analyser.get_value(e);
        //v.mask(32);
        // TEMP now only 32-bit
        //i32 s = cast<i32>(v.svalue);
        //printf("Value %d  %d  %d\n", v.svalue, v.uvalue, cast<u32>(s));
        //out.print("%d", cast<u32>(s));
        out.print("%d", v.as_u32());
#endif
        break;
    case Not:
        ir.Ref lhs;
        gen.emitExpr(&lhs, uo.getInner());

        // xor with -1
        ir.Ref rhs = gen.ctx.addIntegerConstant(-1);
        *result = gen.ctx.addBinaryInstr(InstrKind.Xor, lhs, rhs);
        break;
    case LNot:
        ir.Ref lhs;
        gen.emitExpr(&lhs, uo.getInner());

        // convert integer to bool: compare to 0
        ir.Ref zero = gen.ctx.addIntegerConstant(0);
        ir.Ref rhs = gen.ctx.addBinaryInstr(InstrKind.CmpNe, lhs, zero);

        // invert: xor with 1
        ir.Ref one = gen.ctx.addIntegerConstant(1);
        rhs = gen.ctx.addBinaryInstr(InstrKind.Xor, rhs, one);

        // TODO zext i1 -> i32
        *result = rhs;
        break;
    }
}

fn void Generator.emitBinaryOperator(Generator* gen, ir.Ref* result, const Expr* e) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);

    switch (b.getOpcode()) {
    case Multiply:
    case Divide:
    case Remainder:
    case Add:
    case Subtract:
        break;
    case ShiftLeft:
    case ShiftRight:
        gen.emitShift(result, e);
        return;
    case LessThan:
    case GreaterThan:
    case LessEqual:
    case GreaterEqual:
    case Equal:
    case NotEqual:
        break;
    case And:
    case Xor:
    case Or:
        break;
    case LAnd:
        gen.emitLogicalAnd(result, e);
        return;
    case LOr:
        gen.emitLogicalOr(result, e);
        return;
    case Assign:
        ir.Ref src;
        gen.emitExpr(&src, b.getRHS());
        ir.Ref dest;
        gen.emitExpr(&dest, b.getLHS());
        // TODO get type (from either side, should be same by now)
        gen.ctx.addStoreInstr(ir.Type.I32, dest, src);
        return;
    case MulAssign:
    case DivAssign:
    case RemAssign:
    case AddAssign:
    case SubAssign:
    case ShlAssign:
    case ShrAssign:
    case AndAssign:
    case XorAssign:
    case OrAssign:
        gen.emitOpAssign(result, e);
        return;
    }

    // TODO use array with instructions (combine with signed/unsigned)
    InstrKind kind = InstrKind.None;
    switch (b.getOpcode()) {
    case Multiply:
        kind = InstrKind.Mul;
        break;
    case Divide:
        // TODO udiv
        //instr = "div";
        assert(0);
        break;
    case Remainder:
        // TODO urem
        //instr = "rem";
        assert(0);
        break;
    case Add:
        kind = InstrKind.Add;// TODO or FAdd
        break;
    case Subtract:
        //instr = "sub";
        assert(0);
        break;
    case LessThan:
        kind = InstrKind.CmpLt;
        break;
    case GreaterThan:
        kind = InstrKind.CmpGt;
        break;
    case LessEqual:
        kind = InstrKind.CmpLe;
        break;
    case GreaterEqual:
        kind = InstrKind.CmpGe;
        break;
    case Equal:
        kind = InstrKind.CmpEq;
        break;
    case NotEqual:
        kind = InstrKind.CmpNe;
        break;
    case And:
        kind = InstrKind.And;
        break;
    case Xor:
        kind = InstrKind.Xor;
        break;
    case Or:
        kind = InstrKind.Or;
        break;
    default:
        assert(0);
        break;
    }
    assert(kind != InstrKind.None);

    ir.Ref left;
    gen.emitExpr(&left, b.getLHS());
    ir.Ref right;
    gen.emitExpr(&right, b.getRHS());

    *result = gen.ctx.addBinaryInstr(kind, left, right);
}

// 2 cases: as if/while/for condition or outside
// this is the outside case-> should return a result
fn void Generator.emitLogicalAnd(Generator* gen, ir.Ref* result, const Expr* e) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);
    ir.Context* c = gen.ctx;

    // convert into number, need Phi instr
#if 0
    //gen.emitCond(b.getLHS(), and_true, false_blk);
    //gen.emitCond(b.getRHS(), true_blk, false_blk);

    BlockId and_cond = c.createBlock(BlockKind.AndCond);
    BlockId and_true = c.createBlock(BlockKind.AndTrue);
    BlockId and_join = c.createBlock(BlockKind.AndJoin);
    ir.Ref left;

    ir.Ref cond1 = gen.emitCondition(cast<Stmt*>(b.getLHS()));
    c.addJmpIfInstr(cond1, and_cond, and_join);
    c.endBlock();

    c.startBlock(and_cond);
    ir.Ref cond2 = gen.emitCondition(cast<Stmt*>(b.getRHS()));
    c.addJmpIfInstr(cond2, and_true, and_join);
    c.endBlock();

    c.startBlock(and_true);
    //gen.emitExpr(&right, b.getRHS());

    // TODO check for CTV
    // NOTE: need to convert either side to bool and branch if true (lazy evaluation)
    // InstrKind k = is_and ? InstrKind.LAnd : InstrKind.LOr;
    // *result = gen.ctx.addBinaryInstr(k, left, right);
#endif
}

fn void Generator.emitLogicalOr(Generator* gen, ir.Ref* result, const Expr* e) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);

    //ir.Ref left;
    //gen.emitExpr(&left, b.getLHS());
    // TODO
}

fn void Generator.emitShift(Generator* gen, ir.Ref* result, const Expr* e) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);
    InstrKind k;
    if (b.getOpcode() == BinaryOpcode.ShiftLeft) {
        k = InstrKind.Shl;
    } else {
        //QualType qt = e.getType();
        //if (qt.isUnsigned()) instr = "shr";
        //else instr = "sar";
        k = InstrKind.Shr;
    }

    ir.Ref left;
    gen.emitExpr(&left, b.getLHS());
    ir.Ref right;
    gen.emitExpr(&right, b.getRHS());

    *result = gen.ctx.addBinaryInstr(k, left, right);
}

fn void Generator.emitOpAssign(Generator* gen, ir.Ref* result, const Expr* e) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);

    // TODO put in global array (also use in Generic)
    // Compare: size <=4 -> w variant, else l variant
    //              signed:   csltw / csltl
    //              unsigned: cultw / cultl
    //              float:    clts / cltd
    // same for greater, etc
    InstrKind k = InstrKind.None;
    switch (b.getOpcode()) {
    case MulAssign:
        k = InstrKind.Mul;
        break;
    case DivAssign:
        k = InstrKind.Div;
        // udiv
        break;
    case RemAssign:
        // urem
        k = InstrKind.Rem;
        break;
    case AddAssign:
        k = InstrKind.Add;
        break;
    case SubAssign:
        k = InstrKind.Sub;
        break;
    case ShlAssign:
        //instr = "shl";
        break;
    case ShrAssign:
        // TODO sar/shr
        //instr = "shr";
        break;
    case AndAssign:
        k = InstrKind.And;
        break;
    case XorAssign:
        k = InstrKind.Xor;
        break;
    case OrAssign:
        k = InstrKind.Or;
        break;
    default:
        assert(0);
        return;
    }
    assert(k != InstrKind.None);

    ir.Ref left;
    gen.emitExpr(&left, b.getLHS());

    // emit as lvalue (=load)
    ir.Type t = ir.Type.I32; // TODO get type from Expr
    ir.Ref left_val = gen.ctx.addLoadInstr(t, left);

    ir.Ref right;
    gen.emitExpr(&right, b.getRHS());

    right = gen.ctx.addBinaryInstr(k, left_val, right);
    gen.ctx.addStoreInstr(t, left, right);
}

// EmitCond will end with the true_blk started
fn void Generator.emitCond(Generator* gen, const Expr* e, BlockId true_blk, BlockId false_blk, BlockId start_blk) {
    ir.Context* c = gen.ctx;

    if (e.isCtv()) {
        Value v = ctv_analyser.get_value(e);
        if (v.isZero()) {
            c.addJmpInstr(false_blk);
        } else {
            c.addJmpInstr(true_blk);
        }
        c.endBlock();
        c.startBlock(start_blk);
        return;
    }

    ir.Ref ref;

    switch (e.getKind()) {
    case IntegerLiteral:
    case FloatLiteral:
    case BooleanLiteral:
    case CharLiteral:
    case StringLiteral:
    case Nil:
        assert(0);  // CTV
        break;
    case Identifier:
        assert(0); // should have cast?
        break;
    case Type:
        assert (0);
        break;
    case Call:
        break;
    case InitList:
    case FieldDesignatedInit:
    case ArrayDesignatedInit:
        assert (0);
        break;
    case BinaryOperator:
        if (gen.emitBinaryCond(e, true_blk, false_blk, start_blk)) return;
        break;
    case UnaryOperator:
        break;
    case ConditionalOperator:
        assert(0);
        break;
    case Builtin:
        assert(0);  // CTV
        break;
    case ArraySubscript:
    case Member:
        break;
    case Paren:
        ParenExpr* p = cast<ParenExpr*>(e);
        gen.emitCond(p.getInner(), true_blk, false_blk, start_blk);
        return;
    case BitOffset:
    case ExplicitCast:
    case ImplicitCast:
        break;
    }
    gen.emitExpr(&ref, e);
    ir.Ref zero = gen.ctx.addIntegerConstant(0);
    ir.Ref cond = gen.ctx.addBinaryInstr(InstrKind.CmpNe, ref, zero);
    c.addJmpIfInstr(cond, true_blk, false_blk);
    c.endBlock();
    c.startBlock(start_blk);


}

fn bool Generator.emitBinaryCond(Generator* gen, const Expr* e, BlockId left, BlockId right, BlockId start) {
    Context* c = gen.ctx;
    const BinaryOperator* b = cast<BinaryOperator*>(e);

    InstrKind k;
    switch (b.getOpcode()) {
    case LessThan:
        k = InstrKind.CmpLt;
        break;
    case GreaterThan:
        k = InstrKind.CmpGt;
        break;
    case LessEqual:
        k = InstrKind.CmpLe;
        break;
    case GreaterEqual:
        k = InstrKind.CmpGe;
        break;
    case Equal:
        k = InstrKind.CmpEq;
        break;
    case NotEqual:
        k = InstrKind.CmpNe;
        break;
    case LAnd:
        gen.emitAndCond(b, left, right);
        return true;
    case LOr:
        gen.emitOrCond(b, left, right, start);
        return true;
    default:
        return false;
    }

    ir.Ref lhs;
    gen.emitExpr(&lhs, b.getLHS());
    ir.Ref rhs;
    gen.emitExpr(&rhs, b.getRHS());
    ir.Ref cond = gen.ctx.addBinaryInstr(k, lhs, rhs);
    c.addJmpIfInstr(cond, left, right);
    c.endBlock();
    c.startBlock(start);
    return true;
}

fn void Generator.emitAndCond(Generator* gen, const BinaryOperator* b, BlockId true_blk, BlockId false_blk) {
    BlockId and_true = gen.ctx.createBlock(BlockKind.AndTrue);

    gen.emitCond(b.getLHS(), and_true, false_blk, and_true);
    gen.emitCond(b.getRHS(), true_blk, false_blk, true_blk);
}

fn void Generator.emitOrCond(Generator* gen, const BinaryOperator* b, BlockId true_blk, BlockId false_blk, BlockId start_blk) {
    BlockId or_false = gen.ctx.createBlock(BlockKind.OrFalse);

    gen.emitCond(b.getLHS(), true_blk, or_false, or_false);
    gen.emitCond(b.getRHS(), true_blk, false_blk, start_blk);
}

fn void Generator.emitArraySubscript(Generator* gen, ir.Ref* result, const Expr* e) {
    const ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
    Expr* base = a.getBase();
    Expr* index = a.getIndex();
    QualType qt = base.getType();
    u32 base_size = qt.getSize(true);

    if (index.isCtv()) {
        ir.Ref base_ref;
        gen.emitExpr(&base_ref, base);

        // offset = value * base_size;
        Value v = ctv_analyser.get_value(index);
        u32 offset = v.as_u32() * base_size;
        ir.Ref offset_ref = gen.ctx.addIntegerConstant(offset);

        // add base and offset
        *result = gen.ctx.addBinaryInstr(InstrKind.Add, base_ref, offset_ref);
    } else {
        ir.Ref base_ref;
        gen.emitExpr(&base_ref, base);

        ir.Ref idx_ref;
        gen.emitExpr(&idx_ref, index);

        // offset = value * base_size;
        ir.Ref size_ref = gen.ctx.addIntegerConstant(base_size);
        ir.Ref offset_ref = gen.ctx.addBinaryInstr(InstrKind.Mul, idx_ref, size_ref);

        // add base and offset
        *result = gen.ctx.addBinaryInstr(InstrKind.Add, base_ref, offset_ref);
    }
}

fn void Generator.emitMemberExpr(Generator* gen, ir.Ref* result, const Expr* e) {
    const MemberExpr* m = cast<MemberExpr*>(e);
    Context* c = gen.ctx;
    IdentifierKind kind = m.getKind();

    if (kind == IdentifierKind.Var || kind == IdentifierKind.Function) {
        assert(!m.hasExpr());
        Decl* d = m.getFullDecl();
        //getGlobalName(result.ref, d);
        assert(0); // TODO
        return;
    }

    assert(kind == IdentifierKind.StructMember);

#if 0
    if (m.hasExpr()) {
        const Expr* base = m.getExprBase();
        base.dump();
    }
    for (u32 i=0; i<m.getNumRefs(); i++) {
        Decl* d = m.getDecl(i);
        QualType qt = d.getType();
        bool needs_deref = qt.isPointer();
        stdio.printf("REF[%d] %d\n", i, needs_deref);
        d.dump();
    }
#endif

    // base
    ir.Ref base_ref;
    QualType base_type;
    u32 idx = 0;
    if (m.hasExpr()) {
        const Expr* base = m.getExprBase();
        gen.emitExpr(&base_ref, base);
        base_type = base.getType();
    } else {
        const Decl* base = m.getDecl(idx);
        if (base.isImport()) {  // skip module prefix
            idx++;
            base = m.getDecl(idx);
        }
        idx++;
        assert(base.isVarDecl());
        gen.emitVarDecl(&base_ref, base);
        base_type = base.getType();
    }

    // member (a.b.c.etc)
    u32 numrefs = m.getNumRefs();
    for (u32 i=idx; i<numrefs; i++) {
        if (base_type.isPointer()) { // insert load to de-ref
            base_ref = c.addLoadInstr(ir.Type.I32, base_ref);
            base_type = base_type.getPointerBaseType();
        }

        assert(base_type.isStruct());
        const StructType* st = base_type.getStructType();
        const StructTypeDecl* std = st.getDecl();

        Decl* d = m.getDecl(i);

        u32 offset = 0;
        Decl* dd = std.findMember(d.getNameIdx(), &offset);
        assert(dd);

        if (offset != 0) {
            ir.Ref offset_ref = c.addIntegerConstant(offset);
            base_ref = c.addBinaryInstr(InstrKind.Add, base_ref, offset_ref);
        }

        base_type = d.getType();
    }
    *result = base_ref;
}

