/* Copyright 2022-2024 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module qbe_generator;

import ast local;
import component;
import console;
import constants;
import string_buffer;
import ctv_analyser;
import process_utils;
import file_utils;
import linked_list;

import string;
import stdlib;
import stdio;

const char[] QBE_Dir = "qbe";
const char[] QBE_Filename = "main.qbe";
const char[] LogFile = "build.log";

type Generator struct {
    string_buffer.Buf* out;
    string_buffer.Buf* start;
    string_buffer.Buf* strings;
    const char* target;
    const char* output_dir;
    bool cur_external;  // whether current component is external
    bool print;
    u32 string_idx; // for string literals
    u32 substruct_idx;  // for unnamed substructs/unions
    Locals locals;

    u32 block_idx;
    bool block_terminated; // ends with jmp/jnz/ret
}

fn u32 Generator.getNewBlockIndex(Generator* gen) {
    return gen.block_idx++;
}

fn void Generator.startBlock(Generator* gen, const char* name, const char* comments) {
    //if (!gen.block_terminated) {
        //gen.out.print("\tjmp %s\n", name);
    //}
    gen.block_terminated = false;
    gen.out.print("%s\t\t# %s\n", name, comments);
}

fn void addStructName(string_buffer.Buf* out, const Decl* d) {
    assert(d.getName());
    out.add1(':');
    out.add(d.getModuleName());
    out.add1('_');
    out.add(d.getName());
}

fn void addGlobalName(string_buffer.Buf* out, const Decl* d) {
    out.add1('$');
    if (d.isExternal()) {
        const char* cname = d.getCName();
        if (cname) {
            out.add(cname);
        } else {
            out.add(d.getName());
        }
        return;
    }
    out.add(d.getModuleName());
    out.add1('_');
    if (d.isFunction()) {
        FunctionDecl* fd = cast<FunctionDecl*>(d);
        Ref* prefix = fd.getPrefix();
        if (prefix) {
            out.add(ast.idx2name(prefix.name_idx));
            out.add1('_');
        }
    }
    if (d.isEnumConstant()) {
        QualType qt = d.getType();
        EnumType* et = cast<EnumType*>(qt.getType());
        out.add(et.getName());
        out.add1('_');
    }
    out.add(d.getName());
}

fn void addType(string_buffer.Buf* out, QualType qt) {
    const StructType* s = qt.getStructTypeOrNil();
    if (s) {
        addStructName(out, cast<Decl*>(s.getDecl()));
    } else {
        if (qt.getAlignment() == 8) out.add1('l');
        else out.add1('w');
    }
}

fn void Generator.addParam(Generator* gen, u32 idx, VarDecl* vd) {
    string_buffer.Buf* out = gen.out;
    QualType qt = vd.asDecl().getType();
    // Parameters have a temp %1, .. and a %3, ..
    Var* var = gen.locals.find(vd);
    assert(var);

    switch (var.align) {
    case 1:
        out.add1('w');
        gen.start.print("\tstoreb %%.%d, %%.%d\n", idx, var.slot);
        break;
    case 2:
        out.add1('w');
        gen.start.print("\tstoreh %%.%d, %%.%d\n", idx, var.slot);
        break;
    case 4:
        out.add1('w');
        gen.start.print("\tstorew %%.%d, %%.%d\n", idx, var.slot);
        break;
    case 8:
        out.add1('l');
        gen.start.print("\tstorel %%.%d, %%.%d\n", idx, var.slot);
        break;
    default:
        assert(0);
        break;
    }
    out.print(" %%.%d", idx);
}

fn char align2char(u32 align) {
    if (align == 8) return 'l';
    if (align == 4) return 'w';
    if (align == 2) return 's';
    if (align == 1) return 'b';
    assert(0);
    return '?';
}

fn char align2store(u32 align) {
    if (align == 4) return 'w';
    if (align == 2) return 'h';
    if (align == 1) return 'b';
    return 'l';
}

fn void Generator.emitFunction(Generator* gen, Decl* d) {
    gen.start.clear();
    gen.locals.clear();
    FunctionDecl* fd = cast<FunctionDecl*>(d);
    string_buffer.Buf* out = gen.out;

    if (d.isPublic()) out.add("export "); // TEMP not if single file, unless main

    out.add("function ");

    if (fd.hasReturn()) {
        addType(out, fd.getRType());
        out.space();
    }

    out.add1('$');
    // TODO add module name, except for main
    // TEMP do smarter
    bool has_prefix = !d.isPublic() || (string.strcmp(d.getName(), "main") != 0);
    if (has_prefix) {
        out.add(d.getModuleName());
        out.add1('_');
    }
    const Ref* prefix = fd.getPrefix();
    if (prefix) {
        out.add(prefix.getName());
        out.add1('_');
    }
    out.add(d.getName());
    out.lparen();

    u32 num_params = fd.getNumParams();

    gen.start.clear();
    gen.start.print("@start.%d\n", gen.getNewBlockIndex());
    gen.block_terminated = false;

    // generate a map for all locals -> temp slots
    // TODO also collect Decl if condition is a DeclStmt (If, While, For, Do)
    gen.collectLocals(fd);
    //gen.locals.dump();
    // alloc4/8, align 1/2/4/8 never use alloc1/2??

    VarDecl** fn_params = fd.getParams();
    for (u32 i=0; i<num_params; i++) {
        if (i != 0) out.add(", ");
        // we know the first num_param slots are params, so generate store for them
        gen.addParam(i+1, fn_params[i]);
    }
    if (fd.isVariadic()) {
        if (num_params) out.add(", ");
        out.add("...");
    }
    out.add(") {\n");
    out.add(gen.start.data());
    gen.start.clear();

    gen.emitFunctionBody(fd);
    out.add("}\n\n");
}

fn void Generator.emitFunctionBody(Generator* gen, const FunctionDecl* fd) {
    bool have_ret = false;
    CompoundStmt* body = fd.getBody();
    const u32 num_stmts = body.getCount();
    Stmt** stmts = body.getStmts();
    for (u32 i=0; i<num_stmts; i++) {
        const Stmt* s = stmts[i];
        gen.emitStmt(s);
    }

    if (!gen.block_terminated) gen.out.add("\tret\n");
}

fn void Generator.doArrayInit(Generator* gen, const ArrayType* at, const Expr* e) {
    string_buffer.Buf* out = gen.out;
    u32 num_elems = at.getSize();
    QualType elem = at.getElemType();
    u32 elemSize = elem.getSize();

    u32 len;
    if (e.isStringLiteral()) {
        const StringLiteral* str = cast<StringLiteral*>(e);
        const char* text = str.getText();
        out.print("b \"%s\\000\"", text);
        len = cast<u32>(string.strlen(text)) + 1;
    } else {
        assert(e.isInitList());
        InitListExpr* ile = cast<InitListExpr*>(e);
        u32 count  = ile.getNumValues();
        Expr** inits = ile.getValues();

        const StructType* st = elem.getStructTypeOrNil();
        if (st) {
            for (u32 i=0; i<count; i++) {
                if (i != 0) out.add(", ");
                gen.doStructInit(st, inits[i]);
            }
        } else {
            char name = align2store(elemSize);
            for (u32 i=0; i<count; i++) {
                if (i != 0) out.add(", ");
                out.print("%c ", name);
                ExprRef result;
                gen.emitExpr(&result, inits[i]);
            }
        }

        len = count * elemSize;
    }

    u32 num_zeroes = (num_elems * elemSize) - len;
    if (num_zeroes) {
        if (len) out.add(", ");
        out.print("z %d", num_zeroes);
    }
}

fn void Generator.doStructInit(Generator* gen, const StructType* st, const Expr* e) {
    string_buffer.Buf* out = gen.out;
    //StructTypeDecl* std = st.getDecl();
    // TODO also generate padding (eg. z 3)
    // TODO
}

fn void Generator.handleVarDecl(Generator* gen, Decl* d) {
    // TODO only for externals
    if (!d.isUsed()) return;

    const VarDecl* vd = cast<VarDecl*>(d);
    string_buffer.Buf* out = gen.out;

    QualType qt = d.getType();
    u32 align = qt.getAlignment();  // TODO add convenience function to Decl? (saves copies)
    u32 size = qt.getSize();  // TODO add convenience function to Decl? (saves copies)
    // TODO dont generate CTV variables (add bit in VarDecl? is_constant)

    if (d.isPublic()) out.add("export ");

    out.add("data ");
    addGlobalName(out, d);
    out.print(" = align %d { ", align);

    const Expr* initExpr = vd.getInit();
    if (initExpr) {
        ArrayType* at = qt.getArrayTypeOrNil();
        const StructType* st = qt.getStructTypeOrNil();
        if (at) {
            gen.doArrayInit(at, initExpr);
        } else if (st) {
            gen.doStructInit(st, initExpr);
        } else {
            out.print("%c ", align2store(size));
            ExprRef result;
            gen.emitExpr(&result, initExpr);
        }
    } else {
        out.print("z %d", size);
    }

    out.add(" }\n");
}

fn void addMember(string_buffer.Buf* out, QualType qt) {
    const StructType* s = qt.getStructTypeOrNil();
    if (s) {
        addStructName(out, cast<Decl*>(s.getDecl()));
        return;
    }
    const ArrayType* a = qt.getArrayTypeOrNil();
    u32 align = qt.getAlignment();
    if (a) {
        // note: for multi-dimensional arrays, multiply all sizes
        u32 size = a.getSize();
        while (1) {
            qt = a.getElemType();
            a = qt.getArrayTypeOrNil();
            if (!a) break;
            size *= a.getSize();
        }
        out.add1(align2char(align));
        out.print(" %d", size);
        return;
    }
    out.add1(align2char(align));
}

fn u32 Generator.createStruct(Generator* gen, StructTypeDecl* s, bool is_global) {
    string_buffer.Buf* out = gen.out;
    //struct:  type :.2 = { w, w, b, }
    //union:  type :anon0 = { { w } { b } }
    if (s.asDecl().isGenerated()) return 0;
    // Note: dont use gen.out

    const u32 num_members = s.getNumMembers();
    Decl** members = s.getMembers();

    u32 anon_id = 0;
    out.add("type ");
    if (is_global) {
        addStructName(out, cast<Decl*>(s));
    } else {
        anon_id = gen.substruct_idx;
        out.print(":anon%d", anon_id);
        gen.substruct_idx++;
    }
    out.add(" = { ");
    // Union:  type :test = { { w } { b 12 } }
    // Struct: type :test = { w, b 12 }
    bool is_union = s.isUnion();
    const char* inter = is_union ? " " : ", ";
    for (u32 i=0; i<num_members; i++) {
        Decl* member = members[i];
        if (i != 0) out.add(inter);
        if (is_union) out.add1('{');
        if (member.isStructType()) { // substructs
            u32 sub_id = gen.createStruct(cast<StructTypeDecl*>(member), false);
            out.print(":anon%d", sub_id);
        } else {
            assert(member.isVariable());
            // if VarDecl is StructType, generate that first (not if Struct*)
            QualType qt = member.getType();
            StructType* st = qt.getStructTypeOrNil();
            if (st) {
                StructTypeDecl* s2 = st.getDecl();
                if (!s2.asDecl().isGenerated()) {
                    gen.createStruct(s2, true);
                }
            }
            addMember(out, member.getType());
        }
        if (is_union) out.add1('}');
    }
    out.add(" }\n");
    s.asDecl().setGenerated();
    return anon_id;
}

fn void Generator.handleStruct(Generator* gen, Decl* d) {
    // TODO do normal write in normal case, insert optional fragments later

    if (d.isGenerated()) return;
    StructTypeDecl* s = cast<StructTypeDecl*>(d);

    gen.createStruct(s, true);
}

fn void Generator.on_decl(void* arg, Decl* d) {
    Generator* gen = arg;
    switch (d.getKind()) {
    case Function:
        if (!gen.cur_external) gen.emitFunction(d);
        break;
    case Import:
        return;
    case StructType:
        gen.handleStruct(d);
        break;
    case EnumType:
        break;
    case EnumConstant:
        break;
    case FunctionType:
        break;
    case AliasType:
        break;
    case Variable:
        gen.handleVarDecl(d);
        break;
    }
}

fn void Generator.on_ast(void* arg, AST* a) {
    a.visitDecls(Generator.on_decl, arg);
}

fn void Generator.on_module(void* arg, Module* m) {
    if (m.isUsed()) {
        Generator* gen = arg;
        gen.out.print("\n# --- module %s ---\n\n", m.getName());
        // TODO first types, then globals, then functions
        m.visitASTs(Generator.on_ast, arg);
        gen.out.add(gen.strings.data());
        gen.strings.clear();
    }
}

fn void Generator.init(Generator* gen, const char* target, const char* output_dir, bool print) {
    string.memset(gen, 0, sizeof(Generator));
    gen.out = string_buffer.create(256*1024, false, 1);
    gen.start = string_buffer.create(1024, false, 1);
    gen.strings = string_buffer.create(4*1024, false, 1);
    gen.target = target;
    gen.output_dir = output_dir;
    // starting at 1 looks nicer
    gen.string_idx = 1;
    gen.locals.init();
    gen.print = print;
}

fn void Generator.free(Generator* gen) {
    gen.locals.free();
    gen.strings.free();
    gen.start.free();
    gen.out.free();
}

fn void Generator.write(Generator* gen, const char* output_dir, const char* filename) {
    char[constants.Max_path] fullname;
    stdio.sprintf(fullname, "%s/%s", output_dir, filename);

    file_utils.Writer writer;
    bool ok = writer.write(fullname, cast<u8*>(gen.out.data()), gen.out.size());
    if (!ok) {
        console.error("%s", writer.getError());
    }
}

fn void Generator.createMakefile(Generator* gen, const char* output_dir) {
    string_buffer.Buf* out = gen.out;
    out.clear();
    out.add("# This makefile is auto-generated, any modifications will be lost\n\n");
    out.print("../%s: main.o\n", gen.target);
    out.print("\t\tgcc main.o -o ../%s\n\n", gen.target);

    out.add("main.o: main.s\n");
    out.add("\t\tas main.s -o main.o\n\n");

    out.add("main.s: main.qbe\n");
    out.add("\t\tqbe -t amd64_sysv main.qbe -o main.s\n\n");

    // alt to avoid GCC: (Linux specific)
    // LIBDIR=/usr/lib/x86_64-linux-gnu
    // LOADER=/lib64/ld-linux-x86-64.so.2
    // ld -dynamic-linker $(LOADER) -o test main.o $(LIBDIR)/Scrt1.o $(LIBDIR)/libc.so $(LIBDIR)/crti.o $(LIBDIR)/crtn.o

    out.add("clean:\n");
    out.add("\t\trm -f main.o main.s test\n\n");

    gen.write(output_dir, "Makefile");
}

public fn void generate(const char* target, const char* output_dir, component.List* comps, bool print) {
    // TODO put in aux-pool? (lowers stack-size)
    char[constants.Max_path] qbe_dir;
    stdio.sprintf(qbe_dir, "%s/%s", output_dir, QBE_Dir);
    i32 err = file_utils.create_directory(qbe_dir);
    if (err) {
        console.error("cannot create directory %s: %s", qbe_dir, string.strerror(err));
        return;
    }

    Generator gen;
    gen.init(target, qbe_dir, print);

    for (u32 i=0; i<comps.size(); i++) {
        component.Component* c = comps.get(i);
        gen.cur_external = c.isExternal();
        c.visitModules(Generator.on_module, &gen);
    }
    if (gen.print) stdio.puts(gen.out.data());

    gen.write(qbe_dir, QBE_Filename);

    gen.createMakefile(qbe_dir);

    gen.free();
}

public fn void build(const char* output_dir)
{
    // TODO put in aux-pool? (lowers stack-size)
    char[constants.Max_path] dir;
    stdio.sprintf(dir, "%s/%s/", output_dir, QBE_Dir);

    i32 retval = process_utils.run(dir, "/usr/bin/make", LogFile);
    if (retval != 0) {
        console.error("error during external QBE compilation");
        console.log("see %s%s for defails", dir, LogFile);
    }
}

fn void Generator.addLocalVar(Generator* gen, VarDecl* vd) {
    QualType qt = vd.asDecl().getType();
    const StructType* s = qt.getStructTypeOrNil();
    u32 width;
    u32 align;
    if (s) {
        const StructTypeDecl* std = s.getDecl();
        width = std.getSize();
        align = std.getAlignment();
    } else {
        // HMM weird
        width = qt.getAlignment();
        align = width;
    }
    u32 size = qt.getSize();
    u32 slot = gen.locals.add(vd, width, align, size);
    // QBE has no explicitc size, for arrays, just set alignment to total size

    string_buffer.Buf* out = gen.start;
    switch (align) {
    case 1:
        out.print("\t%%.%d =l alloc4 %d", slot, size);
        break;
    case 2:
        out.print("\t%%.%d =l alloc4 %d", slot, size);
        break;
    case 4:
        out.print("\t%%.%d =l alloc4 %d", slot, size);
        break;
    case 8:
        out.print("\t%%.%d =l alloc8 %d", slot, size);
        break;
    default:
        out.print("\t%%.%d =l alloc4 %d", slot, size);
        break;
    }
    out.print("\t\t# %s\n", vd.getName());
}

fn void Generator.collectLocals(Generator* gen, const FunctionDecl* fd) {
    VarDecl** fn_params = fd.getParams();
    u32 num_params = fd.getNumParams();
    gen.locals.skipSlots(num_params);

    for (u32 i=0; i<num_params; i++) {
        gen.addLocalVar(fn_params[i]);
    }
    // TODO handle varargs, how?

    gen.collectLocalVars(cast<Stmt*>(fd.getBody()));
}

fn void Generator.collectLocalVars(Generator* gen, Stmt* s) {
    switch (s.getKind()) {
    case If:
        const IfStmt* if_stmt = cast<IfStmt*>(s);
        gen.collectLocalVars(if_stmt.getCond());
        Stmt* then_stmt = if_stmt.getThen();
        if (then_stmt) gen.collectLocalVars(then_stmt);
        Stmt* else_stmt = if_stmt.getElse();
        if (else_stmt) gen.collectLocalVars(else_stmt);
        break;
    case While:
        // TODO
        break;
    case Do:
        // TODO
        break;
    case For:
        // TODO
        break;
    case Switch:
        // TODO
        break;
    case Compound:
        CompoundStmt* c = cast<CompoundStmt*>(s);
        const u32 num_stmts = c.getCount();
        Stmt** stmts = c.getStmts();
        for (u32 i=0; i<num_stmts; i++) {
            gen.collectLocalVars(stmts[i]);
        }
        break;
    case Decl:
        const DeclStmt* ds = cast<DeclStmt*>(s);
        gen.addLocalVar(ds.getDecl());
        break;
    default:
        break;
    }
}

fn void Generator.createTemp(Generator* gen, char* out) {
    stdio.sprintf(out, "%%.%d", gen.locals.get());
}

