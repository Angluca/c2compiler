/* Copyright 2022-2024 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module qbe_generator;

import ast local;
import ctv_analyser;
import string_buffer;

import stdio local;

// either holds %.12 or constant 123
type ExprRef struct {
    char[24] ref;   // should be big enough to hold all CTV values
}

// TODO remove string_buffer arg
fn void Generator.emitExpr(Generator* gen, ExprRef* result, string_buffer.Buf* out, const Expr* e) {
    result.ref[0] = 0;  // sanity

    if (e.isCtv()) {
        Value v = ctv_analyser.get_value(e);
        // TODO negative values (seems as 64-bit unsigned)
        sprintf(result.ref, "%d", v.uvalue);
        return;
    }

    // Note: not all expr here are CTV, mainly ArrayToPointerDecay or Arrays
    switch (e.getKind()) {
    case IntegerLiteral:    fallthrough;
    case FloatLiteral:      fallthrough;
    case BooleanLiteral:    fallthrough;
    case CharLiteral:
        assert(0);  // should be handled by CTV above
        break;
    case StringLiteral:
        // NOTE this is the case for char* a = "text", NOT char[] a = "text"
        // TODO should be turned into global, return ref to globol
        sprintf(result.ref, "$string.%d", 1234);
        break;
    case Nil:
        out.add1('0');
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        const Decl* d = i.getDecl();
        assert(d);
        assert(d.isVariable());
        const VarDecl* vd = cast<VarDecl*>(d);
        if (vd.isLocal() || vd.isParameter()) {
            Var* var = gen.locals.find(vd);
            assert(var);
            sprintf(result.ref, "%%.%d", var.slot);
        } else if (vd.isGlobal()) {
            // TODO
            sprintf(result.ref, "$TODO");
        } else {
            assert(0);
        }
        break;
    case Type:
        assert(0);
        break;
    case Call:
        CallExpr* ce = cast<CallExpr*>(e);
        // TODO add implicit args etc
        u32 num_args = ce.getNumArgs();
        Expr** args = ce.getArgs();
        // for printf("hello") -> %.5 =w call $printf(l $.Lstring.6)
        // TODO get full name
        const char* name = "$printf";
        for (u32 a=0; a<num_args; a++) {
            const Expr* arg = args[a];
            if (a != 0) out.add(", ");
            out.add("l ");    // TEMP, always 'l' TODO use size of function-decl
            ExprRef dontcare;
            gen.emitExpr(&dontcare, out, arg);
        }
        out.add(")\n");
        // TODO it it results something use that
        break;
    case InitList:  fallthrough;
    case FieldDesignatedInit: fallthrough;
    case ArrayDesignatedInit:
        assert(0);
        break;
    case BinaryOperator:
        gen.emitBinaryOperator(result, out, e);
        break;
    case UnaryOperator:
        gen.emitUnaryOperator(out, e);
        break;
    case ConditionalOperator:   fallthrough;
    case Builtin:
        // TODO
        break;
    case ArraySubscript:
        const ArraySubscriptExpr* a = cast<ArraySubscriptExpr*>(e);
        Expr* base = a.getBase();
        Expr* index = a.getIndex();
        u32 base_size = 4;
        // TODO need size of base, store inside? ArraySubscriptExpr? or get from QualType
        if (index.isCtv()) {
            // offset = value * base_size;
            Value v = ctv_analyser.get_value(index);
            v.uvalue *= base_size;

            ExprRef base_ref;
            gen.emitExpr(&base_ref, out, base);

            // %x = add %base, offset
            gen.createTemp(result.ref);
            out.print("\t%s =l add %s, %d\n", result.ref, base_ref.ref, v.uvalue);
        } else {
            ExprRef idx_ref;
            gen.emitExpr(&idx_ref, out, index);

            // %x = mul %index, base_size
            ExprRef tmp;
            gen.createTemp(tmp.ref);
            out.print("\t%s =l mul %d, %s\n", tmp.ref, base_size, idx_ref.ref);

            ExprRef base_ref;
            gen.emitExpr(&base_ref, out, base);

            // %y = add %base, %x
            gen.createTemp(result.ref);
            out.print("\t%s =l add %s, %s\n", result.ref, base_ref.ref, tmp.ref);
        }
        break;
    case Member:    fallthrough;
    case Paren: fallthrough;
    case BitOffset: fallthrough;
    case ExplicitCast:
        // TODO
        break;
    case ImplicitCast:
        ImplicitCastExpr* ic = cast<ImplicitCastExpr*>(e);
        switch (ic.getKind()) {
        case ArrayToPointerDecay:
            // just ignore, pass inner
            gen.emitExpr(result, out, ic.getInner());
            break;
        case FunctionToPointerDecay:
            // just ignore, pass inner
            gen.emitExpr(result, out, ic.getInner());
            break;
        case LValueToRValue:
            // turn into load
            ExprRef res;
            gen.emitExpr(&res, out, ic.getInner());
            gen.createTemp(result.ref);
            out.print("\t%s =l loadw %s\n", result.ref, res.ref);
            break;
        case PointerToBoolean:
            assert(0);
            break;
        case PointerToInteger:
            assert(0);
            break;
        case IntegralCast:
            assert(0);
            break;
        case BitCast:
            assert(0);
            break;
        }
        break;
    }
}

fn void Generator.emitUnaryOperator(Generator* gen, string_buffer.Buf* out, const Expr* e) {
    const UnaryOperator* uo = cast<UnaryOperator*>(e);
    switch (uo.getOpcode()) {
    case PostInc:
        break;
    case PostDec:
        break;
    case PreInc:
        break;
    case PreDec:
        break;
    case AddrOf:
        break;
    case Deref:
        break;
    case Minus:
        // QBE has no signed, emit unsigned variant
        assert(e.isCtc());
        Value v = ctv_analyser.get_value(e);
        // TEMP now only 32-bit
        i32 s = cast<i32>(v.svalue);
        //printf("Value %d  %d  %d\n", v.svalue, v.uvalue, cast<u32>(s));
        out.print("%d", cast<u32>(s));
        break;
    case Not:
        break;
    case LNot:
        break;
    }
}

fn void Generator.emitBinaryOperator(Generator* gen, ExprRef* result, string_buffer.Buf* out, const Expr* e) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);
    switch (b.getOpcode()) {
    case Multiply:
        break;
    case Divide:
        break;
    case Remainder:
        break;
    case Add:
        break;
    case Subtract:
        break;
    case ShiftLeft:
        break;
    case ShiftRight:
        break;
    case LessThan:    fallthrough;
    case GreaterThan: fallthrough;
    case LessEqual:   fallthrough;
    case GreaterEqual: fallthrough;
    case Equal:       fallthrough;
    case NotEqual:
        gen.emitBinopCompare(result, out, b);
        break;
    case And:
        break;
    case Xor:
        break;
    case Or:
        break;
    case LAnd:
        break;
    case LOr:
        break;
    case Assign:
        ExprRef src;
        gen.emitExpr(&src, out, b.getRHS());
        ExprRef dest;
        gen.emitExpr(&dest, out, b.getLHS());
        out.print("\tstorew %s, %s\n", src.ref, dest.ref);
        break;
    case MulAssign:
        break;
    case DivAssign:
        break;
    case RemAssign:
        break;
    case AddAssign:
        break;
    case SubAssign:
        break;
    case ShlAssign:
        break;
    case ShrAssign:
        break;
    case AndAssign:
        break;
    case XorAssign:
        break;
    case OrAssign:
        break;
    }
}

fn void Generator.emitBinopCompare(Generator* gen, ExprRef* result, string_buffer.Buf* out, const BinaryOperator* b) {
    // TODO also handle unsigned cases
    const char* instr;
    switch (b.getOpcode()) {
    case LessThan:
        instr = "csltw";
        break;
    case GreaterThan:
        instr = "csgtw";
        break;
    case LessEqual:
        instr = "cslew";
        break;
    case GreaterEqual:
        instr = "csgew";
        break;
    case Equal:
        instr = "ceqw";
        break;
    case NotEqual:
        instr = "cnew";
        break;
    default:
        assert(0);
        break;
    }

    ExprRef left;
    gen.emitExpr(&left, out, b.getLHS());
    ExprRef right;
    gen.emitExpr(&right, out, b.getRHS());

    gen.createTemp(result.ref);
    out.print("\t%s =w %s %s %s\n", result.ref, instr, left.ref, right.ref);
}

