/* Copyright 2022-2024 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module qbe_generator;

import ast local;
import ctv_analyser;
import string_buffer;

import stdio;

fn u32  Generator.emitExpr(Generator* gen, string_buffer.Buf* out, const Expr* e) {
    if (e.isCtv()) {
        Value v = ctv_analyser.get_value(e);
        // TODO negative values (seems as 64-bit unsigned)
        out.print("%d", v.uvalue);
        return 0;   // dont need index
    }

    // Note: not all expr here are CTV, mainly ArrayToPointerDecay or Arrays
    u32 idx = 0;
    switch (e.getKind()) {
    case IntegerLiteral:
        const IntegerLiteral* i =  cast<IntegerLiteral*>(e);
        out.print("%d", i.getValue());
        break;
    case FloatLiteral:
        // TODO
        break;
    case BooleanLiteral:
        const BooleanLiteral* b = cast<BooleanLiteral*>(e);
        out.print("%d", b.getValue());
        break;
    case CharLiteral:
        const CharLiteral* c = cast<CharLiteral*>(e);
        out.print("%d", c.getValue());
        break;
    case StringLiteral:
        // NOTE this is the case for char* a = "text", NOT char[] a = "text"

        out.print("$string.%d", gen.createString(e));
        break;
    case Nil:
        out.add1('0');
        break;
    case Identifier:
        IdentifierExpr* i = cast<IdentifierExpr*>(e);
        const Decl* d = i.getDecl();
        assert(d);
        assert(d.isVariable());
        const VarDecl* vd = cast<VarDecl*>(d);
        if (vd.isLocal() || vd.isParameter()) {
            Var* var = gen.locals.find(vd);
            assert(var);
            idx = gen.locals.get();
            out.print("\t%%.%d =w loadw %%.%d\n", idx, var.slot);
        } else if (vd.isGlobal()) {
        } else {
            assert(0);
        }
        // check if local or global

        break;
    case Type:
        assert(0);
        break;
    case Call:  fallthrough;
    case InitList:  fallthrough;
    case FieldDesignatedInit:   fallthrough;
    case ArrayDesignatedInit:   fallthrough;
    case BinaryOperator:
        return gen.emitBinaryOperator(out, e);
    case UnaryOperator:
        gen.emitUnaryOperator(out, e);
        break;
    case ConditionalOperator:   fallthrough;
    case Builtin:   fallthrough;
    case ArraySubscript:    fallthrough;
    case Member:    fallthrough;
    case Paren: fallthrough;
    case BitOffset: fallthrough;
    case ExplicitCast:
        // TODO
        break;
    case ImplicitCast:
        ImplicitCastExpr* ic = cast<ImplicitCastExpr*>(e);
        return gen.emitExpr(out, ic.getInner());
    }

    return idx;
}

fn void Generator.emitUnaryOperator(Generator* gen, string_buffer.Buf* out, const Expr* e) {
    const UnaryOperator* uo = cast<UnaryOperator*>(e);
    switch (uo.getOpcode()) {
    case PostInc:
        break;
    case PostDec:
        break;
    case PreInc:
        break;
    case PreDec:
        break;
    case AddrOf:
        break;
    case Deref:
        break;
    case Minus:
        // QBE has no signed, emit unsigned variant
        assert(e.isCtc());
        Value v = ctv_analyser.get_value(e);
        // TEMP now only 32-bit
        i32 s = cast<i32>(v.svalue);
        //stdio.printf("Value %d  %d  %d\n", v.svalue, v.uvalue, cast<u32>(s));
        out.print("%d", cast<u32>(s));
        break;
    case Not:
        break;
    case LNot:
        break;
    }
}

fn u32 Generator.emitBinaryOperator(Generator* gen, string_buffer.Buf* out, const Expr* e) {
    const BinaryOperator* b = cast<BinaryOperator*>(e);
    const Expr* lhs = b.getLHS();
    const Expr* rhs = b.getRHS();

    // TODO handle all types

    // could be nested (a > (b + 2)
    // a > b -> %1 = load a; %2 = load b; %3 = csgtw %1, %2;
    // a > 3 -> %1 = load a, %2 = csgtw %1, 3;
    // 10 > 2 is CTC, (so should not happen) %1 = csgtw 10 2;

    u32 ltmp = 0;
    if (!lhs.isCtv()) ltmp = gen.emitExpr(out, lhs);
    u32 rtmp = 0;
    if (!rhs.isCtv()) rtmp = gen.emitExpr(out, rhs);

    u32 result_tmp = gen.locals.get();
    // TEMP just assume int -> csgtw

    out.print("\t%%.%d =w csgtw ", result_tmp);
    if (ltmp) {
        out.print("%%.%d", ltmp);
    } else {
        gen.emitExpr(out, lhs);
    }
    out.add(", ");
    if (rtmp) {
        out.print("%%.%d", rtmp);
    } else {
        gen.emitExpr(out, rhs);
    }
    out.newline();
    return result_tmp;
}

