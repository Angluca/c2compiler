/* Copyright 2022-2024 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module qbe_generator;

import ast local;
import component;
import console;
import constants;
import string_buffer;
import ctv_analyser;
import process_utils;
import file_utils;
import linked_list;

import string;
import stdlib;
import stdio local;

fn const char* Generator.exprRhs(Generator* gen, const Expr* e, string_buffer.Buf* out) {
    local char[64] tmp;
    tmp[0] = 0;
    string_buffer.Buf* buf = string_buffer.create_static(sizeof(tmp), false, tmp);
    if (e.isCtv()) {
        gen.emitExpr(buf, e);
    } else {
        u32 tmp2 = gen.emitExpr(out, e);
        buf.print("%%.%d", tmp2);
    }
    buf.free();
    return tmp;
}

fn bool Generator.emitStmt(Generator* gen, const Stmt* s, string_buffer.Buf* out) {
    switch (s.getKind()) {
    case Return:
        const ReturnStmt* r = cast<ReturnStmt*>(s);
        const Expr* retval = r.getValue();
        if (retval) {
            // TODO could also pass 2 string_buffers: pre and post (nesting?)
            out.print("\tret %s", gen.exprRhs(retval, out));
        } else {
            out.add("\tret");
        }
        out.newline();
        gen.block_terminated = true;
        return false;
    case Expr:
        gen.emitExpr(out, cast<Expr*>(s));
        break;
    case If:
        const IfStmt* if_stmt = cast<IfStmt*>(s);
        // TODO also collect Decl if condition is a DeclStmt
        const Stmt* cond = if_stmt.getCond();
        const Stmt* then_stmt = if_stmt.getThen();
        const Stmt* else_stmt = if_stmt.getElse();

        // generate condition, could be Decl: Foo* f = getFoo() or something
        assert(cond.isExpr());

        Expr* e = cast<Expr*>(cond);
        if (e.isCtv()) {
            Value v = ctv_analyser.get_value(e);
            if (v.uvalue == 0) {
                if (else_stmt) gen.emitStmt(else_stmt, out);
            } else {
                gen.emitStmt(then_stmt, out);
            }
            return true;
        }

        u32 tmp = gen.emitExpr(out, cast<Expr*>(cond));

        char[64] blk_name1;
        char[64] blk_name2;
        char[64] blk_name3;
        sprintf(blk_name1, "@if_true.%d", gen.getNewBlockIndex());
        sprintf(blk_name3, "@if_join.%d", gen.getNewBlockIndex());

        if (else_stmt) {
            sprintf(blk_name2, "@if_false.%d", gen.getNewBlockIndex());
            out.print("\tjnz %%.%d, %s, %s\n", tmp, blk_name1, blk_name2);
        } else {
            out.print("\tjnz %%.%d, %s, %s\n", tmp, blk_name1, blk_name3);
        }

        // then-block
        gen.startBlock(blk_name1, blk_name1, out);
        gen.emitStmt(then_stmt, out);
        out.print("\tjmp %s\n", blk_name3);

        // optional else-block
        if (else_stmt) {
            gen.startBlock(blk_name2, blk_name2, out);
            gen.emitStmt(else_stmt, out);
            // NOTE: no jump needed, but insert anyways (good practice?) next block is join
            out.print("\tjmp %s\n", blk_name3);
        }
        // join block
        gen.startBlock(blk_name3, blk_name3, out);
        break;
    case Compound:
        CompoundStmt* c = cast<CompoundStmt*>(s);
        const u32 num_stmts = c.getCount();
        Stmt** stmts = c.getStmts();
        for (u32 i=0; i<num_stmts; i++) {
            bool more = gen.emitStmt(stmts[i], out);
            if (!more) break;
        }
        break;

    case Decl:
        // already has slot
        const DeclStmt* ds = cast<DeclStmt*>(s);
        VarDecl* vd = ds.getDecl();
        const Expr* ie = vd.getInit();
        if (ie) {
            Var* var = gen.locals.find(vd);
            assert(var);
            // TEMP only simple ones
            if (ie.isIntegerLiteral()) {
                IntegerLiteral* il = cast<IntegerLiteral*>(ie);
                QualType qt = vd.asDecl().getType();
                out.print("\tstore%c ", align2store(qt.getAlignment()));
                il.printDecimal(out);
                out.print(", %%.%d\n", var.slot);
            }
        }
        break;
    default:
        // TODO handle all kinds
        break;
    }
    return true;
}

