/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ir;

import interference_graph local;

import stdlib;
import string;
import stdio local;

// TEMP here
type LiveIndex struct {
    u16 start;  // in temps array
    u16 count;
}

type LiveVector struct  {
    u32 count;  // total count
    u32 start; // where current blocks temps start
    u32 cap;
    u32 index_cap;
    u32* temps;
    LiveIndex* indexes;  // block-id is index

    // TEMP HERE, should be placed in tools and created once
    InterferenceGraph* interferences;
}

fn void LiveVector.init(LiveVector* v, u32 num_blocks) {
    v.count = 0;
    v.start = 0;
    v.cap = 1024;
    v.temps = stdlib.malloc(v.cap * sizeof(u32));

    v.index_cap = num_blocks;
    v.indexes = stdlib.malloc(v.index_cap * sizeof(LiveIndex));

    // TODO this should be re-used between functions (also LiveVector)
    // TODO let number of variables depend on nr of instructions
    v.interferences = interference_graph.create(32*1024, 2048);
}

fn void LiveVector.free(LiveVector* v) {
    v.interferences.free();
    stdlib.free(v.temps);
}

fn void LiveVector.add(LiveVector* v, u32 idx) {
    assert(idx <= 65535);
    //if (v.count == v.cap) printf("add %d/%d  %d\n", v.count, v.cap, idx);
    //printf("  add %d/%d  %d\n", v.count, v.cap, idx);
    for (u32 i=v.start; i<v.count; i++) {
        if (v.temps[i] == idx) return;    // already in, ignore
    }
    // Note: interferes with all other vars in there
    for (u32 i=v.start; i<v.count; i++) {
        //printf("  %d interferes with %d\n", idx, v.temps[i]);
        v.interferences.add((u16)idx, (u16)v.temps[i]);
    }
    assert(v.count < v.cap);
    v.temps[v.count] = idx;
    v.count++;
}

fn void LiveVector.remove(LiveVector* v, u32 idx) {
    //printf("remove %d\n", idx);
    for (u32 i=v.start; i<v.count; i++) {
        if (v.temps[i] == idx) {    // swap with last
            v.count--;
            if (i != v.count) v.temps[i] = v.temps[v.count];
            return;
        }
    }
    //printf("  not found\n");
}

fn void LiveVector.store(LiveVector* v, u32 blk_id) {
    assert(blk_id < v.index_cap);
    LiveIndex* idx = &v.indexes[blk_id];
    idx.start = (u16)v.start;
    idx.count = (u16)(v.count - v.start);
    v.start = v.count;
    //printf("STORE B%d  %d  %d\n", blk_id, idx.start, idx.count);
}

fn void LiveVector.copy(LiveVector* v, u32 blk_id) {
    assert(blk_id < v.index_cap);
    const LiveIndex* src = &v.indexes[blk_id];
    //printf("  COPY %d (%d %d)\n", blk_id, src.start, src.count);
    assert(v.count + src.count < v.cap);
    string.memcpy(&v.temps[v.count], &v.temps[src.start], src.count * sizeof(u32));
    v.count += src.count;
}

fn void LiveVector.merge(LiveVector* v, u32 blk_id) {
    assert(blk_id < v.index_cap);
    const LiveIndex* src = &v.indexes[blk_id];
    //printf("  MERGE %d (%d %d)\n", blk_id, src.start, src.count);
    u32 last = src.start + src.count;
    for (u32 i = src.start; i < last; i++) v.add(v.temps[i]);
}

fn void LiveVector.dump(const LiveVector* v) @(unused) {
    printf("Live: ");
    for (u32 i=v.start; i<v.count; i++) {
        printf(" %d", v.temps[i]);
    }
    printf("\n");
}

fn void LiveVector.dumpRanges(const LiveVector* v) @(unused) {
    printf("Live ranges");
    for (u32 i=v.start; i<v.index_cap; i++) {
        const LiveIndex* idx = &v.indexes[i];
        printf("  B%d %2d|%2d: ", i, idx.start, idx.count);
        for (u32 j=idx.start; j<idx.start+idx.count; j++) {
            printf(" %d", v.temps[j]);
        }
        printf("\n");
    }
}

fn void Tools.allocateRegisters(Tools* t, FunctionInfo* fi) {
    LiveVector v.init(fi.blocks.getCount());

    Block* blocks = fi.blocks.get(0);
    for (u32 i=0; i<fi.blocks.getCount(); i++) {
        blocks[i].checked = false;
    }

    // TODO can manually allocate registers to params here already (R0..Rx)
    // that would still be ISA independent

    t.checkBlockReg(0, fi, &v);

    //v.dumpRanges();

    //v.interferences.dump(false);
    v.interferences.allocate();

    // replace temps with registers
    const u8* regmap = v.interferences.getRegs();
    u32 num_instr = fi.instructions.getCount();
    Instr* instrs = fi.instructions.get(0);
    for (u32 i=0; i<num_instr; i++) {
        Instr* ii = &instrs[i];
        if (ii.hasResult()) ii.setReg(regmap[i]);

        if (ii.isPhi()) {
            // nothing to do
        } else if (ii.isCall()) {
            if (ii.args[1].isRefList()) {
                Ref* refs = fi.refs.get(ii.args[1].value);
                u32 idx = 0;
                while (1) {
                    Ref* r2 = &refs[idx];
                    if (r2.isTemp()) r2.setRegister(regmap[r2.value]);
                    if (!r2.isValid()) break;
                    idx++;
                }
            }
        } else {
            if (ii.args[0].isTemp()) {
                ii.args[0].setRegister(regmap[ii.args[0].value]);
            }
            if (ii.args[1].isTemp()) {
                ii.args[1].setRegister(regmap[ii.args[1].value]);
            }
        }
    }
    // replace all temps in Phi-clauses
    PhiClause* clauses = fi.phis.get(0);
    for (u32 i=0; i<fi.phis.getCount(); i++) {
        PhiClause* pc = &clauses[i];
        pc.dest_idx = regmap[pc.dest_idx];
        if (pc.ref.isTemp()) {
            pc.ref.setRegister(regmap[pc.ref.value]);
        }
    }

    v.free();
    t.replacePhis(fi);
}

fn void Tools.checkBlockReg(Tools* t, u32 blk_id, FunctionInfo* fi, LiveVector* v) {
    //printf("CHECK B%d\n", blk_id);
    Block* b = fi.blocks.get(blk_id);
    //printf("CHECK BLK %d\n", blk_id);

    // algoritm:
    // 1. get LiveIn from successors
    // 2. merge these into own LiveOut
    // 3. if phi-block, add Phi clauses to LiveOut
    // 4. iterate all instructions bottom -> top, checking for interference
    // 5. store LiveIn in LiveVector, mark is done

    // step 0 - check if already checked, return results
    if (b.checked) return;

    // step 1 - get LiveIn from successors
    // TEST since blocks are ordered, back jumps are loops. These are already handled by phi.
    // so try ignoring them.
    if (b.dests[0] > blk_id) {
        t.checkBlockReg(b.dests[0], fi, v);
    }
    if (b.dests[1] > blk_id) {
        t.checkBlockReg(b.dests[1], fi, v);
    }

    // 2. merge these into own start-set
    if (b.dests[0] > blk_id) v.copy(b.dests[0]);
    if (b.dests[1] > blk_id) v.merge(b.dests[1]);

    //printf("  B%d successors: ", blk_id); v.dump();

    // step 3 - add phi-clauses
    if (b.phi_source) {
        // avoid Lost-copy problem, by checking dependencies between Phi operations
        // Brigg's algorithm:
        // - if there is a copy dest = src, where src is not used as dest in any unprocessed copy, emit it
        //      (and remove from list)
        // - Else, select a cycle (e.g., a := b, b := a) â†’ use a temporary to break it:
        //     t = a; a = b; b = t;
        // Note: need to add instruction and add to Interference graph
        // TODO also add copy instructions

        //printf("B%d phi source\n", blk_id);
        const PhiClause* clauses = fi.phis.get(0);
        u32 num_clauses = fi.phis.getCount();
        for (u32 i=0; i<num_clauses; i++) {
            const PhiClause* c = &clauses[i];
            if (c.src == blk_id) {
                //printf("  B%d remove phi %d\n", blk_id, c.dest_idx);
                v.remove(c.dest_idx);
                if (c.ref.isTemp()) {
                    //printf("  B%d add phi clause %d\n", blk_id, c.ref.value);
                    v.add(c.ref.value);
                }
            }
        }
    }

    // step 4 - iterate all instructions bottom -> top
    Instr* instrs = fi.instructions.get(0);
    assert(b.instr.count);
    u32 first = b.instr.start;
    u32 last = b.instr.start + b.instr.count - 1;
    u32 i = last;
    while (1) {
        const Instr* ii = &instrs[i];

        if (ii.isPhi()) {
            v.interferences.enable((u16)i);
        } else {
            if (ii.hasResult()) {
                v.remove(i);
                v.interferences.enable((u16)i);
            }

            if (ii.isCall()) {
                if (ii.args[1].isRefList()) {
                    Ref* refs = fi.refs.get(ii.args[1].value);
                    u32 idx = 0;
                    while (1) {
                        Ref* r2 = &refs[idx];
                        if (r2.isTemp()) v.add(r2.value);
                        if (!r2.isValid()) break;
                        idx++;
                    }
                }
            } else {
                if (ii.args[0].isTemp()) v.add(ii.args[0].value);
                if (ii.args[1].isTemp()) v.add(ii.args[1].value);
            }
            //printf("[%d] ", i);
            //v.dump();
        }
        if (i == first) break;
        i--;
    }
    //printf("B%d LiveIn ", blk_id); v.dump();

    // 5. store in LiveVector, mark is done
    v.store(blk_id);
    b.checked = true;
}

fn void Tools.replacePhis(Tools* t, FunctionInfo* fi) {
    /*
        If phi-clause source block ends with:
            - 'jmp', just insert 'copy' before it
            - 'jmp_if', create new PhiJoin block as intermediate jump dest

        TODO also need to merge multiple phi's into using same merge block! for B1 -> B2

        B0:                                    B0:
            jmp B2                                 copy 10, %2
        B1:                                        jmp B2
            jmp_if B2, ..                      B1:
        B2:                                        jmp_if MergeB1, ..
            %2 = phi [ @B0: 10, @B1: 20 ]      MergeB1:
                                                   copy 20, %2
                                                   jmp B2
                                               B2:
                                                   -
    */

    // TODO solve swap,lost-copy problems - compare all phi's in block, see if they interfere

    // TODO have Block bit: has_phi, to search faster?

    t.inserter.clear();

    // TODO refactor so that inserter stores new blocks + instructions?
    // -> can also insert block at right position then, no need for tracking block-order
    // otherwise can change during loops
    // TEMP just reserve (too many) extra blocks + instructions
    u32 extra_blocks = fi.phis.getCount();
    u32 extra_instr = 2 * fi.phis.getCount(); // assume new block: copy + jmp
    fi.blocks.reserve(extra_blocks);
    fi.instructions.reserve(extra_instr);

    // Note: cannot get all blocks ptr, since block insertions might re-alloc it
    u32 num_blocks = fi.blocks.getCount();
    Block* blocks = fi.blocks.get(0);
    for (u32 i=0; i<num_blocks; i++) {
        Block* b = &blocks[i];
        u32 last = b.instr.start + b.instr.count;
        for (u32 j=b.instr.start; j<last; j++) {
            Instr* ii = fi.instructions.get(j);
            if (ii.isComment() || ii.isNone()) continue;
            if (!ii.isPhi()) break; // phi-instructions are always at start of block

            const PhiClause* clauses = fi.phis.get(ii.phi_clauses.start);
            for (u32 c=0; c<ii.phi_clauses.count; c++) {
                const PhiClause* pc = &clauses[c];
                Block* src = fi.blocks.get(pc.src);
                if (src.dests[1]) { // jmp_if, create merge_block (if it doesn't already exist)
                    // no need for inserter, just add to new block
                    BlockId cur_blk = fi.blocks.add(BlockKind.PhiJoin);
                    Block* cur = fi.blocks.get(cur_blk);
                    cur.used = 1;
                    cur.instr.start = fi.instructions.getCount();
                    cur.instr.count = 2;    // copy + jmp
                    cur.dests[0] = i;

                    Instr* copy = fi.instructions.add();
                    // Note: dest_idx was changed to register nr in previous step
                    copy.initRegCopy((u8)pc.dest_idx, pc.ref);
                    Instr* jmp = fi.instructions.add();
                    Ref jmp_ref = { .kind = RefKind.JmpDest, .value = 0 }
                    jmp.init1(InstrKind.Jmp, jmp_ref);

                    // modify original dest
                    if (src.dests[0] == i) src.dests[0] = cur_blk;
                    if (src.dests[1] == i) src.dests[1] = cur_blk;
                } else {    // jmp, insert copy here
                    u32 insert_loc = src.instr.start + src.instr.count - 1;
                    t.inserter.add(insert_loc, fi.instructions.getCount());
                    Instr* copy = fi.instructions.add();
                    // Note: dest_idx was changed to register nr in previous step
                    copy.initRegCopy((u8)pc.dest_idx, pc.ref);
                }
            }

            ii.clear();

            // clear optional comment
            if (j+1 < last) {
                ii = fi.instructions.get(j+1);
                if (ii.isComment()) ii.clear();
            }
        }
    }

    fi.phis.clear();
}

