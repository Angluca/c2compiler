/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ir;

import index_list;

fn bool Context.convert_switches(Context* c, FunctionInfo* fi) {

    u32 count = fi.blocks.getCount();
    // TODO add to Tools, dont re-create every time
    index_list.List block_order.init(count + 16);

    // Note: cannot get Block* here and iterate that, since block adds might cause resize
    for (u32 i=0; i<count; i++) {
        block_order.add(i);
        // TODO pass tools?
        Block* b = fi.blocks.get(i);
        if (b.end_with_switch) c.convert_switch_linear(fi, i, &block_order);
    }

    if (count != fi.blocks.getCount()) {
        fi.cases.clear();
        c.reorder_blocks(fi, &block_order);
        block_order.free();
        return true;
    }
    block_order.free();
    return false;
}

fn void Context.convert_switch_linear(Context* c, FunctionInfo* fi, u32 blk_id, index_list.List* block_order) {
    Block* b = fi.blocks.get(blk_id);
    u32 switch_loc = b.instr.start + b.instr.count - 1;
    Instr* ii = fi.instructions.get(switch_loc);

    Ref cond = ii.args[0];
    BlockId join_blk = ii.args[1].value;
    CaseId case_id = b.dests[0];
    u32 num_cases = b.dests[1];

    b.end_with_switch = 0;
    // just convert switch to jmp
    Ref jmp_ref.init(RefKind.JmpDest, 0);
    ii.init1(InstrKind.Jmp, jmp_ref);
    b.setDest(fi.blocks.getCount(), 0);

    u32 loc = fi.instructions.getCount();

    // TODO handle default case
    for (u32 j=0; j<num_cases; j++) {
        BlockId cur_blk = fi.blocks.add(BlockKind.SwitchCond);
        block_order.add(cur_blk);
        Block* cur = fi.blocks.get(cur_blk);
        cur.used = 1;
        cur.instr.start = loc;
        cur.instr.count = 2;

        Case* cc = fi.cases.get(case_id+j);
        BlockId next_blk = (j == num_cases-1) ? join_blk : cur_blk +1;
        cur.setDest(cc.block, next_blk);

        // compare
        Ref cmp_result.init(RefKind.Temp, loc);
        // TEMP assume case value fits a Value Ref
        Ref case_value.init(RefKind.Value, cc.value);
        Instr* i = fi.instructions.add();
        i.init2b(InstrKind.CmpEq, cond, case_value);
        loc++;

        // jump
        i = fi.instructions.add();
        i.init2(InstrKind.JmpIf, cmp_result, jmp_ref);

        loc++;
    }
}

