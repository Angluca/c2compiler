/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module c2_keywords;

import token local;
import string_pool;

import string;

type Keyword struct {
    const char* name;
    Kind kind;
}

const Keyword[] Keywords = {
    { "as",         Kind.KW_as  },
    { "asm",        Kind.KW_asm },
    { "assert",     Kind.KW_assert  },
    { "bool",       Kind.KW_bool    },
    { "break",      Kind.KW_break   },
    { "case",       Kind.KW_case    },
    { "cast",       Kind.KW_cast    },
    { "char",       Kind.KW_char    },
    { "const",      Kind.KW_const   },
    { "continue",   Kind.KW_continue    },
    { "default",    Kind.KW_default },
    { "do",         Kind.KW_do  },
    { "elemsof",    Kind.KW_elemsof },
    { "else",       Kind.KW_else    },
    { "enum",       Kind.KW_enum    },
    { "enum_max",   Kind.KW_enum_max    },
    { "enum_min",   Kind.KW_enum_min    },
    { "f32",        Kind.KW_f32 },
    { "f64",        Kind.KW_f64 },
    { "fallthrough", Kind.KW_fallthrough    },
    { "false",      Kind.KW_false   },
    { "fn",         Kind.KW_fn  },
    { "for",        Kind.KW_for },
    { "goto",       Kind.KW_goto    },
    { "i16",        Kind.KW_i16 },
    { "i32",        Kind.KW_i32 },
    { "i64",        Kind.KW_i64 },
    { "i8",         Kind.KW_i8  },
    { "if",         Kind.KW_if  },
    { "import",     Kind.KW_import  },
    { "isize",      Kind.KW_isize   },
    { "local",      Kind.KW_local   },
    { "module",     Kind.KW_module  },
    { "nil",        Kind.KW_nil },
    { "offsetof",   Kind.KW_offsetof    },
    { "public",     Kind.KW_public  },
    { "reg16",      Kind.KW_reg16   },
    { "reg32",      Kind.KW_reg32   },
    { "reg64",      Kind.KW_reg64   },
    { "reg8",       Kind.KW_reg8    },
    { "return",     Kind.KW_return  },
    { "sizeof",     Kind.KW_sizeof  },
    { "sswitch",    Kind.KW_sswitch },
    { "static_assert", Kind.KW_static_assert    },
    { "struct",     Kind.KW_struct  },
    { "switch",     Kind.KW_switch  },
    { "template",   Kind.KW_template    },
    { "to_container", Kind.KW_to_container  },
    { "true",       Kind.KW_true    },
    { "type",       Kind.KW_type    },
    { "u16",        Kind.KW_u16 },
    { "u32",        Kind.KW_u32 },
    { "u64",        Kind.KW_u64 },
    { "u8",         Kind.KW_u8  },
    { "union",      Kind.KW_union   },
    { "usize",      Kind.KW_usize   },
    { "void",       Kind.KW_void    },
    { "volatile",   Kind.KW_volatile    },
    { "while",      Kind.KW_while   },
}

public type Info struct {
    // Note: should be big enough to hold all keywords (currently 350-ish)
    Kind[512] indexes;
    u32 max_index;
}

public fn void init(Info* info, string_pool.Pool* pool) {
    u32 idx = 0;
    for (u32 i=0; i<elemsof(Keywords); i++) {
        const Keyword* kws = &Keywords[i];
        idx = pool.add(kws.name, string.strlen(kws.name), 1);
        info.indexes[idx] = kws.kind;
    }
    info.max_index = idx;
    assert(info.max_index < elemsof(info.indexes));
}

